{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>LynseDB is a vector database implemented purely in Python, designed to be lightweight, server-optional, and easy to deploy locally or remotely. It offers straightforward and clear Python APIs, aiming to lower the entry barrier for using vector databases.</p> <p>It focuses on achieving 100% recall, prioritizing recall accuracy over high-speed search performance. This approach ensures that users can reliably retrieve all relevant vector data, making LynseDB particularly suitable for applications that require responses within hundreds of milliseconds.</p>"},{"location":"#lynsedb-features","title":"LynseDB features","text":"<p>\u26a1 Server-optional, simple parameters, simple API.</p> <p>\u26a1 Fast, memory-efficient, easily scales to millions of vectors.</p> <p>\u26a1 Based on a generic Python software stack, platform-independent, highly versatile.</p> <p>\u26a1 Recall-prioritized design, lifecycle search caching technology, FieldExpression fast filtering, Field multi-type indexing, and other user-centric features</p>"},{"location":"#some-defects-you-should-know","title":"Some Defects You Should Know","text":"<ul> <li>Not yet backward compatible</li> </ul> <p>LynseDB is actively being updated, and API backward compatibility is not guaranteed. You should use version numbers as a strong constraint during deployment to avoid unnecessary feature conflicts and errors.</p> <ul> <li>Data size constraints</li> </ul> <p>Although our goal is to enable brute force search or inverted indexing on billion-scale vectors, we currently still recommend using it on a scale of millions of vectors or less for the best experience.</p> <ul> <li>Python's native api is not process-safe</li> </ul> <p>The Python native API is recommended for use in single-process environments, whether single-threaded or multi-threaded; for ensuring process safety in multi-process environments, please use the HTTP API.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#prerequisite","title":"Prerequisite","text":"<ul> <li>python version &gt;= 3.9</li> <li>Owns one of the operating systems: Windows, macOS, or Ubuntu (or other Linux distributions). The recommendation is for the latest version of the system, but non-latest versions should also be installable, although they have not been tested.</li> <li>Memory &gt;= 4GB, Free Disk &gt;= 4GB.</li> </ul>"},{"location":"#install-client-api-package-mandatory","title":"Install Client API package (Mandatory)","text":"<pre><code>pip install LynseDB\n</code></pre>"},{"location":"#if-you-wish-to-use-docker-optional","title":"If you wish to use Docker (Optional)","text":"<p>You must first install Docker on the host machine.</p> <p>After installing the Client API package:</p> <pre><code>docker pull birchkwok/lynsedb:latest\n</code></pre>"},{"location":"#license","title":"License","text":""},{"location":"#apache-license","title":"Apache License","text":"<p>Version 2.0, January 2004</p>"},{"location":"FieldExpression/","title":"FieldExpression","text":"<p>FieldExpression is a string parser used to parse field expressions.</p> <p>It can reassemble the parsing result into a Filter object of LynseDB, which can filter the query result. Its main implementation idea is to efficiently create Filters without requiring users to learn the use of complex filtering components such as MatchRange and FieldCondition.</p> <p>It is an important component of LynseDB and can effectively improve the user-friendliness of LynseDB.</p> <ul> <li> <p>Supported syntax:</p> <ul> <li>:field: represents a field, e.g., :order:, :name:, etc.</li> <li>:id: special reserved word for matching IDs</li> </ul> </li> <li> <p>Supported comparison operators:</p> <ul> <li>==</li> <li>!=</li> <li>&gt;=</li> <li>&lt;=</li> <li>&gt;</li> <li>&lt;</li> </ul> </li> <li> <p>Supported logical operators:</p> <ul> <li>and</li> <li>or</li> <li>not</li> <li>in</li> </ul> </li> <li> <p>Supported parentheses:</p> <ul> <li>()</li> </ul> </li> <li> <p>Examples:</p> <ul> <li>:order: &gt; 1</li> <li>:order: &gt;= 1</li> <li>:order: &gt;= 1 and :name: &gt;= 1.3</li> <li>not (:order: == 2)</li> <li>:order: &gt;= 1 and :name: != 1.3 and (:order: == 2 or :name: == 3) and not (:tt: == 2)</li> <li>:id: in [1, 2]</li> <li>:id: not in [1, 2]</li> <li>:id: in [1, 2] and :order: &gt;= 1 and :name: &gt;= 1.3 and (:order: == 2 or :name: == 3) and not (:tt: == 2)</li> </ul> </li> <li> <p>Usage: <pre><code>    &gt;&gt;&gt; expression = \":order: &gt; 1 and :name: &gt;= 1.3 and (:order: == 2 or :name: == 3) and not (:tt: == 2)\"\n    &gt;&gt;&gt; parser = ExpressionParser(expression)\n    &gt;&gt;&gt; pfilter = parser.to_filter()\n    &gt;&gt;&gt; print(pfilter.to_dict())\n    {'must_fields': [\n            {'key': 'order', 'matcher': {'value': 1, 'comparator': 'gt'}},\n            {'key': 'name', 'matcher': {'value': 1.3, 'comparator': 'ge'}}\n        ],\n    'any_fields': [\n            {'key': 'order', 'matcher': {'value': 2, 'comparator': 'eq'}},\n            {'key': 'name', 'matcher': {'value': 3, 'comparator': 'eq'}}\n        ],\n    'must_not_fields': [\n            {'key': 'tt', 'matcher': {'value': 2, 'comparator': 'eq'}}\n        ]\n    }\n</code></pre></p> </li> <li> <p>Efficient syntax:</p> <ul> <li>Use () to group expressions for better readability and maintainability.   Specially when using <code>not</code> operator.</li> <li>Use <code>not in</code> instead of <code>not :field: in [value]</code> when possible.</li> <li>Use <code>not (:field: in [value])</code> or <code>not (:field: in [value])</code>, it can be more efficient.</li> </ul> </li> </ul>"},{"location":"client/","title":"Client Distribution API","text":""},{"location":"client/#lynse.VectorDBClient","title":"<code>VectorDBClient</code>","text":"<p>This class determines whether it is local or remote based on the URI, thereby implementing the distribution of local and remote client communication. The data storage location is also determined accordingly.</p> <ul> <li>When <code>uri</code> is None: The local client is used by default, and the data is stored under the default root path.</li> <li>When <code>uri</code> is a local path: The local client is used, and the data is stored under the specified path.</li> <li>When <code>uri</code> is a remote URL: The remote client is used, and the data is stored on the remote server.</li> </ul> Source code in <code>lynse/__init__.py</code> <pre><code>class VectorDBClient:\n    \"\"\"\n    This class determines whether it is local or remote based on the URI, thereby implementing the distribution of local and remote client communication.\n    The data storage location is also determined accordingly.\n\n    - **When `uri` is None**: The local client is used by default, and the data is stored under the default root path.\n    - **When `uri` is a local path**: The local client is used, and the data is stored under the specified path.\n    - **When `uri` is a remote URL**: The remote client is used, and the data is stored on the remote server.\n    \"\"\"\n    def __init__(self, uri: Union[str, None, Path] = None):\n        \"\"\"\n        Initialize the LynseDB client.\n\n        Parameters:\n            uri (Pathlike or str or None): The URI of the LynseDB server. It can be either a local path or a remote URL.\n\n               - If it is a remote URL, the client will use the HTTP API.\n               - If it is a local path, the client will use the native API.\n                    The path refers to the root path of the LynseDB storage.\n               - If set to None, the client will use the native API,\n                    and the database will be stored in the default root path,\n                    when you need to change the default root path,\n                    you can set the environment variable LYNSE_DEFAULT_ROOT_PATH or change the config file.\n\n        \"\"\"\n        self._is_remote = uri is not None and (uri.startswith('http://') or uri.startswith('https://'))\n\n        if self._is_remote:\n            from spinesUtils.asserts import raise_if\n            import httpx\n\n            raise_if(ValueError, not isinstance(uri, (str, Path)),\n                     'uri must be a string, Pathlike or None')\n            if isinstance(uri, Path):\n                uri = uri.as_posix()\n\n            if uri.startswith('http://') or uri.startswith('https://'):\n                try:\n                    response = httpx.get(uri)\n                    if response.status_code != 200:\n                        raise ConnectionError(f'Failed to connect to the server at {uri}.')\n\n                    try:\n                        rj = response.json()\n                        if rj != {'status': 'success', 'message': 'LynseDB HTTP API'}:\n                            raise ConnectionError(f'Failed to connect to the server at {uri}.')\n                    except Exception as e:\n                        print(e)\n                        raise ConnectionError(f'Failed to connect to the server at {uri}.')\n\n                except httpx.RequestError:\n                    raise ConnectionError(f'Failed to connect to the server at {uri}.')\n        else:\n            uri = Path(uri) if uri is not None else None\n\n        self._uri = uri\n\n    def create_database(self, database_name: str, drop_if_exists: bool = False):\n        \"\"\"\n        Create the database using a lazy mode, where entities are only created when they are actually used.\n\n        Parameters:\n            database_name (str): The name of the database to create.\n            drop_if_exists (bool): Whether to drop the database if it already exists.\n                If set to True, the existing database will be immediately deleted before creating a new one.\n\n        Returns:\n            None\n        \"\"\"\n        from .api.http_api.client_api import raise_error_response\n        from .configs.config import config\n        import httpx\n\n        if not self._is_remote:\n            from .api.native_api.database_manager import DatabaseManager\n\n            db_manager = DatabaseManager(root_path=self._uri or config.LYNSE_DEFAULT_ROOT_PATH)\n            db_manager.register(db_name=database_name)\n\n            if drop_if_exists:\n                _InstanceDistributor(root_path=self._uri or config.LYNSE_DEFAULT_ROOT_PATH,\n                                     database_name=database_name).drop_database()\n        else:\n            try:\n                rj = httpx.post(f'{self._uri}/create_database', json={'database_name': database_name,\n                                                                      'drop_if_exists': drop_if_exists})\n                if rj.status_code != 200:\n                    raise_error_response(rj)\n            except httpx.RequestError:\n                raise ConnectionError(f'Failed to connect to the server at {self._uri}.')\n\n        return _InstanceDistributor(root_path=self._uri or config.LYNSE_DEFAULT_ROOT_PATH, database_name=database_name)\n\n    def get_database(self, database_name: str):\n        \"\"\"\n        Get an existing database.\n\n        Parameters:\n            database_name (str): The name of the database to get.\n\n        Returns:\n            LynseDB: (LocalClient, HTTPClient):\n                The appropriate LynseDB client instance based on the root path.\n                If the root path is a local path, return a LocalClient instance,\n                otherwise return a HTTPClient instance.\n        \"\"\"\n        from spinesUtils.asserts import raise_if\n\n        from .api.http_api.client_api import raise_error_response\n        from .configs.config import config\n        import httpx\n\n        if not self._is_remote:\n            from .api.native_api.database_manager import DatabaseManager\n\n            db_manager = DatabaseManager(root_path=self._uri or config.LYNSE_DEFAULT_ROOT_PATH)\n            databases = db_manager.list_database()\n            raise_if(ValueError, database_name not in databases, f'{database_name} does not exist.')\n        else:\n            try:\n                rj = httpx.get(f'{self._uri}/list_databases')\n                if rj.status_code != 200:\n                    raise_error_response(rj)\n\n                databases = rj.json()['params']['databases']\n                raise_if(ValueError, database_name not in databases, f'{database_name} does not exist.')\n            except httpx.RequestError:\n                raise ConnectionError(f'Failed to connect to the server at {self._uri}.')\n\n        return _InstanceDistributor(root_path=self._uri or config.LYNSE_DEFAULT_ROOT_PATH, database_name=database_name)\n\n    def list_databases(self):\n        \"\"\"\n        List all databases.\n\n        Returns:\n            List: A list of all databases.\n        \"\"\"\n        from .api.http_api.client_api import raise_error_response\n        import httpx\n\n        if not self._is_remote:\n            from .api.native_api.database_manager import DatabaseManager\n            from .configs.config import config\n\n            db_manager = DatabaseManager(root_path=self._uri or config.LYNSE_DEFAULT_ROOT_PATH)\n            return db_manager.list_database()\n        else:\n            try:\n                rj = httpx.get(f'{self._uri}/list_databases')\n                if rj.status_code != 200:\n                    raise_error_response(rj)\n\n                return rj.json()['params']['databases']\n            except httpx.RequestError:\n                raise ConnectionError(f'Failed to connect to the server at {self._uri}.')\n\n    def drop_database(self, database_name: str):\n        \"\"\"\n        Delete a database.\n\n        Parameters:\n            database_name (str): The name of the database to delete.\n\n        Returns:\n            None\n        \"\"\"\n        from .api.http_api.client_api import raise_error_response\n        import httpx\n\n        if not self._is_remote:\n            from .api.native_api.database_manager import DatabaseManager\n            from .configs.config import config\n\n            db_manager = DatabaseManager(root_path=self._uri or config.LYNSE_DEFAULT_ROOT_PATH)\n            databases = db_manager.list_database()\n            if database_name not in databases:\n                return\n            db_manager.delete(database_name)\n        else:\n            try:\n                rj = httpx.post(f'{self._uri}/delete_database', json={'database_name': database_name})\n                if rj.status_code != 200:\n                    raise_error_response(rj)\n            except httpx.RequestError:\n                raise ConnectionError(f'Failed to connect to the server at {self._uri}.')\n\n    def __repr__(self):\n        from .configs.config import config\n        return f'{self.__class__.__name__}(uri={self._uri or \"DefaultRootPath\"})'\n\n    def __str__(self):\n        return self.__repr__()\n</code></pre>"},{"location":"client/#lynse.VectorDBClient.__init__","title":"<code>__init__(uri=None)</code>","text":"<p>Initialize the LynseDB client.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>Pathlike or str or None</code> <p>The URI of the LynseDB server. It can be either a local path or a remote URL.</p> <ul> <li>If it is a remote URL, the client will use the HTTP API.</li> <li>If it is a local path, the client will use the native API.     The path refers to the root path of the LynseDB storage.</li> <li>If set to None, the client will use the native API,     and the database will be stored in the default root path,     when you need to change the default root path,     you can set the environment variable LYNSE_DEFAULT_ROOT_PATH or change the config file.</li> </ul> <code>None</code> Source code in <code>lynse/__init__.py</code> <pre><code>def __init__(self, uri: Union[str, None, Path] = None):\n    \"\"\"\n    Initialize the LynseDB client.\n\n    Parameters:\n        uri (Pathlike or str or None): The URI of the LynseDB server. It can be either a local path or a remote URL.\n\n           - If it is a remote URL, the client will use the HTTP API.\n           - If it is a local path, the client will use the native API.\n                The path refers to the root path of the LynseDB storage.\n           - If set to None, the client will use the native API,\n                and the database will be stored in the default root path,\n                when you need to change the default root path,\n                you can set the environment variable LYNSE_DEFAULT_ROOT_PATH or change the config file.\n\n    \"\"\"\n    self._is_remote = uri is not None and (uri.startswith('http://') or uri.startswith('https://'))\n\n    if self._is_remote:\n        from spinesUtils.asserts import raise_if\n        import httpx\n\n        raise_if(ValueError, not isinstance(uri, (str, Path)),\n                 'uri must be a string, Pathlike or None')\n        if isinstance(uri, Path):\n            uri = uri.as_posix()\n\n        if uri.startswith('http://') or uri.startswith('https://'):\n            try:\n                response = httpx.get(uri)\n                if response.status_code != 200:\n                    raise ConnectionError(f'Failed to connect to the server at {uri}.')\n\n                try:\n                    rj = response.json()\n                    if rj != {'status': 'success', 'message': 'LynseDB HTTP API'}:\n                        raise ConnectionError(f'Failed to connect to the server at {uri}.')\n                except Exception as e:\n                    print(e)\n                    raise ConnectionError(f'Failed to connect to the server at {uri}.')\n\n            except httpx.RequestError:\n                raise ConnectionError(f'Failed to connect to the server at {uri}.')\n    else:\n        uri = Path(uri) if uri is not None else None\n\n    self._uri = uri\n</code></pre>"},{"location":"client/#lynse.VectorDBClient.create_database","title":"<code>create_database(database_name, drop_if_exists=False)</code>","text":"<p>Create the database using a lazy mode, where entities are only created when they are actually used.</p> <p>Parameters:</p> Name Type Description Default <code>database_name</code> <code>str</code> <p>The name of the database to create.</p> required <code>drop_if_exists</code> <code>bool</code> <p>Whether to drop the database if it already exists. If set to True, the existing database will be immediately deleted before creating a new one.</p> <code>False</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>lynse/__init__.py</code> <pre><code>def create_database(self, database_name: str, drop_if_exists: bool = False):\n    \"\"\"\n    Create the database using a lazy mode, where entities are only created when they are actually used.\n\n    Parameters:\n        database_name (str): The name of the database to create.\n        drop_if_exists (bool): Whether to drop the database if it already exists.\n            If set to True, the existing database will be immediately deleted before creating a new one.\n\n    Returns:\n        None\n    \"\"\"\n    from .api.http_api.client_api import raise_error_response\n    from .configs.config import config\n    import httpx\n\n    if not self._is_remote:\n        from .api.native_api.database_manager import DatabaseManager\n\n        db_manager = DatabaseManager(root_path=self._uri or config.LYNSE_DEFAULT_ROOT_PATH)\n        db_manager.register(db_name=database_name)\n\n        if drop_if_exists:\n            _InstanceDistributor(root_path=self._uri or config.LYNSE_DEFAULT_ROOT_PATH,\n                                 database_name=database_name).drop_database()\n    else:\n        try:\n            rj = httpx.post(f'{self._uri}/create_database', json={'database_name': database_name,\n                                                                  'drop_if_exists': drop_if_exists})\n            if rj.status_code != 200:\n                raise_error_response(rj)\n        except httpx.RequestError:\n            raise ConnectionError(f'Failed to connect to the server at {self._uri}.')\n\n    return _InstanceDistributor(root_path=self._uri or config.LYNSE_DEFAULT_ROOT_PATH, database_name=database_name)\n</code></pre>"},{"location":"client/#lynse.VectorDBClient.drop_database","title":"<code>drop_database(database_name)</code>","text":"<p>Delete a database.</p> <p>Parameters:</p> Name Type Description Default <code>database_name</code> <code>str</code> <p>The name of the database to delete.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>lynse/__init__.py</code> <pre><code>def drop_database(self, database_name: str):\n    \"\"\"\n    Delete a database.\n\n    Parameters:\n        database_name (str): The name of the database to delete.\n\n    Returns:\n        None\n    \"\"\"\n    from .api.http_api.client_api import raise_error_response\n    import httpx\n\n    if not self._is_remote:\n        from .api.native_api.database_manager import DatabaseManager\n        from .configs.config import config\n\n        db_manager = DatabaseManager(root_path=self._uri or config.LYNSE_DEFAULT_ROOT_PATH)\n        databases = db_manager.list_database()\n        if database_name not in databases:\n            return\n        db_manager.delete(database_name)\n    else:\n        try:\n            rj = httpx.post(f'{self._uri}/delete_database', json={'database_name': database_name})\n            if rj.status_code != 200:\n                raise_error_response(rj)\n        except httpx.RequestError:\n            raise ConnectionError(f'Failed to connect to the server at {self._uri}.')\n</code></pre>"},{"location":"client/#lynse.VectorDBClient.get_database","title":"<code>get_database(database_name)</code>","text":"<p>Get an existing database.</p> <p>Parameters:</p> Name Type Description Default <code>database_name</code> <code>str</code> <p>The name of the database to get.</p> required <p>Returns:</p> Name Type Description <code>LynseDB</code> <p>(LocalClient, HTTPClient): The appropriate LynseDB client instance based on the root path. If the root path is a local path, return a LocalClient instance, otherwise return a HTTPClient instance.</p> Source code in <code>lynse/__init__.py</code> <pre><code>def get_database(self, database_name: str):\n    \"\"\"\n    Get an existing database.\n\n    Parameters:\n        database_name (str): The name of the database to get.\n\n    Returns:\n        LynseDB: (LocalClient, HTTPClient):\n            The appropriate LynseDB client instance based on the root path.\n            If the root path is a local path, return a LocalClient instance,\n            otherwise return a HTTPClient instance.\n    \"\"\"\n    from spinesUtils.asserts import raise_if\n\n    from .api.http_api.client_api import raise_error_response\n    from .configs.config import config\n    import httpx\n\n    if not self._is_remote:\n        from .api.native_api.database_manager import DatabaseManager\n\n        db_manager = DatabaseManager(root_path=self._uri or config.LYNSE_DEFAULT_ROOT_PATH)\n        databases = db_manager.list_database()\n        raise_if(ValueError, database_name not in databases, f'{database_name} does not exist.')\n    else:\n        try:\n            rj = httpx.get(f'{self._uri}/list_databases')\n            if rj.status_code != 200:\n                raise_error_response(rj)\n\n            databases = rj.json()['params']['databases']\n            raise_if(ValueError, database_name not in databases, f'{database_name} does not exist.')\n        except httpx.RequestError:\n            raise ConnectionError(f'Failed to connect to the server at {self._uri}.')\n\n    return _InstanceDistributor(root_path=self._uri or config.LYNSE_DEFAULT_ROOT_PATH, database_name=database_name)\n</code></pre>"},{"location":"client/#lynse.VectorDBClient.list_databases","title":"<code>list_databases()</code>","text":"<p>List all databases.</p> <p>Returns:</p> Name Type Description <code>List</code> <p>A list of all databases.</p> Source code in <code>lynse/__init__.py</code> <pre><code>def list_databases(self):\n    \"\"\"\n    List all databases.\n\n    Returns:\n        List: A list of all databases.\n    \"\"\"\n    from .api.http_api.client_api import raise_error_response\n    import httpx\n\n    if not self._is_remote:\n        from .api.native_api.database_manager import DatabaseManager\n        from .configs.config import config\n\n        db_manager = DatabaseManager(root_path=self._uri or config.LYNSE_DEFAULT_ROOT_PATH)\n        return db_manager.list_database()\n    else:\n        try:\n            rj = httpx.get(f'{self._uri}/list_databases')\n            if rj.status_code != 200:\n                raise_error_response(rj)\n\n            return rj.json()['params']['databases']\n        except httpx.RequestError:\n            raise ConnectionError(f'Failed to connect to the server at {self._uri}.')\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<pre><code>import lynse\n\nprint(\"LynseDB version is: \", lynse.__version__)\n</code></pre> <pre><code>LynseDB version is:  0.1.5\n</code></pre>"},{"location":"quickstart/#initialize-database","title":"Initialize Database","text":"<p>LynseDB now supports HTTP API and Python native code API.</p> <p>The HTTP API mode requires starting an HTTP server beforehand. You have two options: - start directly.</p> <p>For direct startup, the default port is 7637. You can run the following command in the terminal to start the service: <pre><code>lynse run --host localhost --port 7637\n</code></pre></p> <ul> <li>within Docker</li> </ul> <p>In Docker, You can run the following command in the terminal to start the service: <pre><code>docker run -p 7637:7637 birchkwok/lynsedb:latest\n</code></pre> - Remote deploy</p> <p>If you want to deploy remotely, you can bind the image to port 80 of the remote host, or allow the host to open access to port 7637.   such as: <pre><code>docker run -p 80:7637 birchkwok/lynsedb:latest\n</code></pre></p> <ul> <li>test if api available</li> </ul> <p>You can directly request in the browser http://localhost:7637</p> <p>For port 80, you can use this url: http://localhost</p> <p>If the image is bound to port 80 of the host in remote deployment, you can directly access it http://your_host_ip</p> <pre><code># If you are in a Jupyter environment, you can use this method to start the backend server\n# Ignore this code if you are using docker\nlynse.launch_in_jupyter()\n</code></pre> <pre><code>Server running at http://127.0.0.1:7637\n</code></pre> <pre><code># Use the HTTP API mode, it is suitable for use in production environments.\nclient = lynse.VectorDBClient(\"http://127.0.0.1:7637\")  # If no url is passed, the native api is used.\n# Create a database named \"test_db\", if it already exists, delete it and rebuild it.\nmy_db = client.create_database(\"test_db\", drop_if_exists=True)\n</code></pre>"},{"location":"quickstart/#create-a-collection","title":"create a collection","text":"<p><code>WARNING</code></p> <p>When using the <code>require_collection</code> method to request a collection, if the <code>drop_if_exists</code> parameter is set to True, it will delete all content of the collection if it already exists.</p> <p>A safer method is to use the <code>get_collection</code> method. It is recommended to use the <code>require_collection</code> method only when you need to reinitialize a collection or create a new one.</p> <pre><code>collection = my_db.require_collection(\"test_collection\", dim=4, drop_if_exists=True, description=\"demo collection\")\n</code></pre>"},{"location":"quickstart/#show-database-collections","title":"show database collections","text":"<p>If the pandas library is installed, <code>show_collections_details</code> method will show as a pandas dataframe. Otherwise, it will be a dict.</p> <pre><code>my_db.show_collections_details()\n</code></pre> dim chunk_size dtypes use_cache n_threads warm_up description cache_chunks test_collection 4 100000 float32 True 10 False demo collection 20"},{"location":"quickstart/#update-description","title":"update description","text":"<pre><code>collection.update_description(\"Hello World\")\nmy_db.show_collections_details()\n</code></pre> dim chunk_size dtypes use_cache n_threads warm_up description cache_chunks test_collection 4 100000 float32 True 10 False Hello World 20"},{"location":"quickstart/#add-vectors","title":"Add vectors","text":"<p>When inserting vectors, the collection requires manually running the <code>commit</code> function or inserting within the <code>insert_session</code> function context manager, which will run the <code>commit</code> function in the background.</p> <p>It is strongly recommended to use the <code>insert_session</code> context manager for insertion, as this provides more comprehensive data security features during the insertion process.</p> <pre><code>with collection.insert_session() as session:\n    id = session.add_item(vector=[0.01, 0.34, 0.74, 0.31], id=1, field={'field': 'test_1', 'order': 0})   # id = 1\n    id = session.add_item(vector=[0.36, 0.43, 0.56, 0.12], id=2, field={'field': 'test_1', 'order': 1})   # id = 2\n    id = session.add_item(vector=[0.03, 0.04, 0.10, 0.51], id=3, field={'field': 'test_2', 'order': 2})   # id = 3\n    id = session.add_item(vector=[0.11, 0.44, 0.23, 0.24], id=4, field={'field': 'test_2', 'order': 3})   # id = 4\n    id = session.add_item(vector=[0.91, 0.43, 0.44, 0.67], id=5, field={'field': 'test_2', 'order': 4})   # id = 5\n    id = session.add_item(vector=[0.92, 0.12, 0.56, 0.19], id=6, field={'field': 'test_3', 'order': 5})   # id = 6\n    id = session.add_item(vector=[0.18, 0.34, 0.56, 0.71], id=7, field={'field': 'test_1', 'order': 6})   # id = 7\n    id = session.add_item(vector=[0.01, 0.33, 0.14, 0.31], id=8, field={'field': 'test_2', 'order': 7})   # id = 8\n    id = session.add_item(vector=[0.71, 0.75, 0.91, 0.82], id=9, field={'field': 'test_3', 'order': 8})   # id = 9\n    id = session.add_item(vector=[0.75, 0.44, 0.38, 0.75], id=10, field={'field': 'test_1', 'order': 9})  # id = 10\n\n# If you do not use the insert_session function, you need to manually call the commit function to submit the data\n# collection.commit()\n\n# or use the bulk_add_items function\n# with collection.insert_session():\n#     ids = collection.bulk_add_items([([0.01, 0.34, 0.74, 0.31], 0, {'field': 'test_1', 'order': 0}),\n#                                      ([0.36, 0.43, 0.56, 0.12], 1, {'field': 'test_1', 'order': 1}),\n#                                      ([0.03, 0.04, 0.10, 0.51], 2, {'field': 'test_2', 'order': 2}),\n#                                      ([0.11, 0.44, 0.23, 0.24], 3, {'field': 'test_2', 'order': 3}),\n#                                      ([0.91, 0.43, 0.44, 0.67], 4, {'field': 'test_2', 'order': 4}),\n#                                      ([0.92, 0.12, 0.56, 0.19], 5, {'field': 'test_3', 'order': 5}),\n#                                      ([0.18, 0.34, 0.56, 0.71], 6, {'field': 'test_1', 'order': 6}),\n#                                      ([0.01, 0.33, 0.14, 0.31], 7, {'field': 'test_2', 'order': 7}),\n#                                      ([0.71, 0.75, 0.91, 0.82], 8, {'field': 'test_3', 'order': 8}),\n#                                      ([0.75, 0.44, 0.38, 0.75], 9, {'field': 'test_1', 'order': 9})])\n# print(ids)  # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n</code></pre> <pre><code>2024-09-12 17:33:36 - LynseDB - INFO - Task status: {'status': 'Processing'}\n2024-09-12 17:33:38 - LynseDB - INFO - Task status: {'result': {'collection_name': 'test_collection', 'database_name': 'test_db'}, 'status': 'Success'}\n</code></pre>"},{"location":"quickstart/#find-the-nearest-neighbors-of-a-given-vector","title":"Find the nearest neighbors of a given vector","text":"<p>The default similarity measure for query is Inner Product (IP). You can specify cosine or L2 to obtain the similarity measure you need.</p> <pre><code>ids, scores, fields = collection.search(vector=[0.36, 0.43, 0.56, 0.12], k=3, distance=\"cosine\", return_fields=True)\nprint(\"ids: \", ids)\nprint(\"scores: \", scores)\nprint(\"fields: \", fields)\n</code></pre> <pre><code>ids:  [ 9  5 10]\nscores:  [ 0.18610001 -0.16069996 -0.23799998]\nfields:  [{':id:': 9, 'field': 'test_3', 'order': 8}, {':id:': 5, 'field': 'test_2', 'order': 4}, {':id:': 10, 'field': 'test_1', 'order': 9}]\n</code></pre>"},{"location":"quickstart/#list-data","title":"List data","text":"<pre><code>ids, scores, fields = collection.head(5)\nprint(\"ids: \", ids)\nprint(\"scores: \", scores)\nprint(\"fields: \", fields)\n</code></pre> <pre><code>ids:  [1 2 3 4 5]\nscores:  [[0.01       0.34       0.74000001 0.31      ]\n [0.36000001 0.43000001 0.56       0.12      ]\n [0.03       0.04       0.1        0.50999999]\n [0.11       0.44       0.23       0.23999999]\n [0.91000003 0.43000001 0.44       0.67000002]]\nfields:  [{':id:': 1, 'field': 'test_1', 'order': 0}, {':id:': 2, 'field': 'test_1', 'order': 1}, {':id:': 3, 'field': 'test_2', 'order': 2}, {':id:': 4, 'field': 'test_2', 'order': 3}, {':id:': 5, 'field': 'test_2', 'order': 4}]\n</code></pre> <pre><code>ids, scores, fields = collection.tail(5)\nprint(\"ids: \", ids)\nprint(\"scores: \", scores)\nprint(\"fields: \", fields)\n</code></pre> <pre><code>ids:  [ 6  7  8  9 10]\nscores:  [[0.92000002 0.12       0.56       0.19      ]\n [0.18000001 0.34       0.56       0.70999998]\n [0.01       0.33000001 0.14       0.31      ]\n [0.70999998 0.75       0.91000003 0.81999999]\n [0.75       0.44       0.38       0.75      ]]\nfields:  [{':id:': 6, 'field': 'test_3', 'order': 5}, {':id:': 7, 'field': 'test_1', 'order': 6}, {':id:': 8, 'field': 'test_2', 'order': 7}, {':id:': 9, 'field': 'test_3', 'order': 8}, {':id:': 10, 'field': 'test_1', 'order': 9}]\n</code></pre>"},{"location":"quickstart/#use-fieldexpression-for-result-filtering","title":"Use FieldExpression for result filtering","text":"<p>See FieldExpression Tutorial</p> <pre><code>ids, scores, fields = collection.search(\n    vector=[0.36, 0.43, 0.56, 0.12],\n    k=10,\n    search_filter=\"\"\"\n        :field: == 'test_1' and\n        ((0 &lt;= :order: &lt;= 8) or (:id: in [1, 2, 3, 4, 5])) and\n        not (:id: == 8 and :order: &gt;= 8)\n    \"\"\",\n    return_fields=False\n)\n\nprint(\"ids: \", ids)\nprint(\"scores: \", scores)\nprint(\"fields: \", fields)\n</code></pre> <pre><code>ids:  [2 7 1]\nscores:  [-0.35749996 -0.39020002 -0.39859998]\nfields:  None\n</code></pre>"},{"location":"quickstart/#use-filter-for-freer-conditional-expression","title":"Use Filter for freer conditional expression","text":"<p>Using the Filter class for result filtering can maximize Recall.</p> <p>The Filter class now supports <code>must</code>, <code>any</code>, and <code>must_not</code> parameters, all of which only accept list-type argument values.</p> <p>The filtering conditions in <code>must</code> must be met, those in <code>must_not</code> must not be met.</p> <p>After filtering with <code>must</code> and <code>must_not</code> conditions, the conditions in <code>any</code> will be considered, and at least one of the conditions in <code>any</code> must be met.</p> <p>The filter result must satisfy both <code>must</code> and <code>any</code>, but not <code>must_not</code>.</p> <pre><code>import operator\n\nfrom lynse.field_models import Filter, FieldCondition, MatchField, MatchID, MatchRange\n\nids, scores, fields = collection.search(\n    vector=[0.36, 0.43, 0.56, 0.12],\n    k=10,\n    search_filter=Filter(\n        must=[\n            FieldCondition(key='field', matcher=MatchField('test_1')),  # Support for filtering fields\n        ],\n        any=[\n            FieldCondition(key='order', matcher=MatchRange(start=0, end=8, inclusive=True)),\n            FieldCondition(key=\":id:\", matcher=MatchID([1, 2, 3, 4, 5])),  # Support for filtering IDs\n        ],\n        must_not=[\n            FieldCondition(key=\":id:\", matcher=MatchID([8])),\n            FieldCondition(key='order', matcher=MatchField(8, comparator=operator.ge)),\n        ]\n    ),\n    return_fields=False\n)\n\nprint(\"ids: \", ids)\nprint(\"scores: \", scores)\nprint(\"fields: \", fields)\n</code></pre> <pre><code>ids:  [2 7 1]\nscores:  [-0.35749996 -0.39020002 -0.39859998]\nfields:  None\n</code></pre>"},{"location":"quickstart/#query-fields","title":"Query fields","text":""},{"location":"quickstart/#query-via-fieldexpression","title":"Query via FieldExpression","text":"<pre><code>collection.query(\"\"\"\n    :field: == 'test_1' and\n    ((0 &lt;= :order: &lt;= 8) or (:id: in [1, 2, 3, 4, 5])) and\n    not (:id: == 8 and :order: &gt;= 8)\n\"\"\")\n</code></pre> <pre><code>[{':id:': 1, 'field': 'test_1', 'order': 0},\n {':id:': 2, 'field': 'test_1', 'order': 1},\n {':id:': 7, 'field': 'test_1', 'order': 6}]\n</code></pre>"},{"location":"quickstart/#query-via-filter","title":"Query via Filter","text":"<pre><code>query_filter=Filter(\n    must=[\n        FieldCondition(key='field', matcher=MatchField('test_1')),  # Support for filtering fields\n    ],\n    any=[\n        FieldCondition(key='order', matcher=MatchRange(start=0, end=8, inclusive=True)),\n        FieldCondition(key=\":id:\", matcher=MatchID([1, 2, 3, 4, 5])),  # Support for filtering IDs\n    ],\n    must_not=[\n        FieldCondition(key=\":id:\", matcher=MatchID([8])),\n        FieldCondition(key='order', matcher=MatchField(8, comparator=operator.ge)),\n    ]\n)\n\ncollection.query(query_filter)\n</code></pre> <pre><code>[{':id:': 1, 'field': 'test_1', 'order': 0},\n {':id:': 2, 'field': 'test_1', 'order': 1},\n {':id:': 7, 'field': 'test_1', 'order': 6}]\n</code></pre>"},{"location":"quickstart/#exact-match","title":"Exact Match","text":"<pre><code>collection.query({':id:': 1, 'field': 'test_1', 'order': 0})\n</code></pre> <pre><code>[{':id:': 1, 'field': 'test_1', 'order': 0}]\n</code></pre>"},{"location":"quickstart/#fuzzy-match","title":"Fuzzy Match","text":"<pre><code>collection.query({'field': 'test_1'})\n</code></pre> <pre><code>[{':id:': 1, 'field': 'test_1', 'order': 0},\n {':id:': 2, 'field': 'test_1', 'order': 1},\n {':id:': 10, 'field': 'test_1', 'order': 9},\n {':id:': 7, 'field': 'test_1', 'order': 6}]\n</code></pre>"},{"location":"quickstart/#query-vectors","title":"Query Vectors","text":"<p>Much like query, you can query using either the FieldExpression string or the Filter class, fuzzy match, or exact match.</p> <pre><code>collection.query_vectors(\"\"\"\n    :field: == 'test_1' and\n    ((0 &lt;= :order: &lt;= 8) or (:id: in [1, 2, 3, 4, 5])) and\n    not (:id: == 8 and :order: &gt;= 8)\n\"\"\")\n</code></pre> <pre><code>(array([1, 2, 7]),\n array([[0.01      , 0.34      , 0.74000001, 0.31      ],\n        [0.36000001, 0.43000001, 0.56      , 0.12      ],\n        [0.18000001, 0.34      , 0.56      , 0.70999998]]),\n [{':id:': 1, 'field': 'test_1', 'order': 0},\n  {':id:': 2, 'field': 'test_1', 'order': 1},\n  {':id:': 7, 'field': 'test_1', 'order': 6}])\n</code></pre> <pre><code>collection.query_vectors({'field': 'test_1'})\n</code></pre> <pre><code>(array([ 1,  2,  7, 10]),\n array([[0.01      , 0.34      , 0.74000001, 0.31      ],\n        [0.36000001, 0.43000001, 0.56      , 0.12      ],\n        [0.18000001, 0.34      , 0.56      , 0.70999998],\n        [0.75      , 0.44      , 0.38      , 0.75      ]]),\n [{':id:': 1, 'field': 'test_1', 'order': 0},\n  {':id:': 2, 'field': 'test_1', 'order': 1},\n  {':id:': 7, 'field': 'test_1', 'order': 6},\n  {':id:': 10, 'field': 'test_1', 'order': 9}])\n</code></pre>"},{"location":"quickstart/#drop-a-collection","title":"Drop a collection","text":"<p><code>WARNING: This operation cannot be undone</code></p> <pre><code>print(\"Collection list before dropping:\", my_db.show_collections())\nstatus = my_db.drop_collection(\"test_collection\")\nprint(\"Collection list after dropped:\", my_db.show_collections())\n</code></pre> <pre><code>Collection list before dropping: ['test_collection']\nCollection list after dropped: []\n</code></pre>"},{"location":"quickstart/#drop-the-database","title":"Drop the database","text":"<p><code>WARNING: This operation cannot be undone</code></p> <pre><code>my_db.drop_database()\nmy_db\n</code></pre> <pre><code>RemoteDatabaseInstance(name=test_db, exists=False)\n</code></pre>"},{"location":"http_api/client_api/","title":"HTTP Client API","text":""},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection","title":"<code>Collection</code>","text":"<p>The Collection class is used to interact with a collection in the LynseDB.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>class Collection:\n    \"\"\"\n    The Collection class is used to interact with a collection in the LynseDB.\n    \"\"\"\n    name = \"Remote\"\n\n    def __init__(self, uri, database_name, collection_name, **params):\n        \"\"\"\n        Initialize the collection.\n\n        Parameters:\n            uri (str): The URI of the server.\n            database_name (str): The name of the database.\n            collection_name (str): The name of the collection.\n            **params: The collection parameters.\n                - dim (int): The dimension of the vectors.\n                - chunk_size (int): The chunk size.\n                - dtypes (str): The data types.\n                - use_cache (bool): Whether to use cache.\n                - n_threads (int): The number of threads.\n                - warm_up (bool): Whether to warm up.\n                - drop_if_exists (bool): Whether to drop the collection if it exists.\n                - cache_chunks (int): The number of chunks to cache.\n\n        \"\"\"\n        self.IS_DELETED = False\n        self._uri = uri\n        self._database_name = database_name\n        self._collection_name = collection_name\n        self._session = Poster()\n        self._init_params = params\n\n        self.COMMIT_FLAG = False\n\n        self._mesosphere_list = queue.Queue()\n        self._lock = ThreadLock()\n\n    def _get_commit_msg(self):\n        \"\"\"\n        Get the commit message.\n\n        Returns:\n            str: The last commit time.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        uri = f'{self._uri}/get_commit_msg'\n        data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name}\n\n        response = self._session.post(uri, json=data)\n\n        rj = response.json()\n        if response.status_code == 200:\n            if (rj['params']['commit_msg'] is None or\n                    rj['params']['commit_msg'] == 'No commit message found for this collection'):\n                return None\n            return rj['params']['commit_msg']['last_commit_time']\n        else:\n            raise ExecutionError(rj)\n\n    def _update_commit_msg(self, last_commit_time):\n        \"\"\"\n        Update the commit message.\n\n        Parameters:\n            last_commit_time (str): The last commit time.\n\n        Returns:\n            dict: The response from the server.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        uri = f'{self._uri}/update_commit_msg'\n        data = {\n            \"database_name\": self._database_name,\n            \"collection_name\": self._collection_name,\n            \"last_commit_time\": last_commit_time,\n        }\n\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            return response.json()\n        else:\n            try:\n                rj = response.json()\n                raise ExecutionError(rj)\n            except Exception as e:\n                print(e)\n                raise ExecutionError(response.text)\n\n    def exists(self):\n        \"\"\"\n        Check if the collection exists.\n\n        Returns:\n            bool: Whether the collection exists.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n\n        \"\"\"\n        uri = f'{self._uri}/is_collection_exists'\n        data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name}\n\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            return response.json()['params']['exists']\n        else:\n            raise_error_response(response)\n\n    def add_item(self, vector: Union[list[float], np.ndarray], id: int, *, field: Union[dict, None] = None,\n                 buffer_size: int = True):\n        \"\"\"\n        Add an item to the collection.\n        It is recommended to use incremental ids for best performance.\n\n        Parameters:\n            vector (list[float], np.ndarray): The vector of the item.\n            id (int): The ID of the item.\n            field (dict, optional): The fields of the item.\n            buffer_size (int or bool): The buffer size.\n                Default is True, which means the default buffer size (1000) will be used.\n                If buffer_size is 0, the function will add the item directly.\n                If buffer_size is greater than 0, the function will add the item to the buffer.\n                If buffer_size is False, the function will add the item directly and not use the buffer.\n                If buffer_size is True, the function will add the item to the buffer and use the default buffer size.\n\n        Returns:\n            int: The ID of the item.\n                If delay_num is greater than 0, and the number of items added is less than delay_num,\n                the function will return None. Otherwise, the function will return the IDs of the items added.\n\n        Raises:\n            ValueError: If the collection has been deleted or does not exist.\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        if buffer_size is True:\n            buffer_size = 1000\n        else:\n            if buffer_size is False:\n                buffer_size = 0\n            else:\n                raise_if(ValueError, (not isinstance(buffer_size, int)) or buffer_size &lt; 0,\n                         'If buffer_size is not bool, it must be a positive integer.')\n\n        if buffer_size == 0:\n            uri = f'{self._uri}/add_item'\n            headers = {\n                'Content-Type': 'application/msgpack'\n            }\n\n            data = {\n                \"database_name\": self._database_name,\n                \"collection_name\": self._collection_name,\n                \"item\": {\n                    \"vector\": vector if isinstance(vector, list) else vector.tolist(),\n                    \"id\": id,\n                    \"field\": field if field is not None else {},\n                },\n            }\n\n            response = self._session.post(uri, data=None, content=pack_data(data), headers=headers)\n\n            if response.status_code == 200:\n                self.COMMIT_FLAG = False\n                return response.json()['params']['item']['id']\n            else:\n                raise_error_response(response)\n        else:\n            with self._lock:\n                self._mesosphere_list.put({\n                    \"vector\": vector if isinstance(vector, list) else vector.tolist(),\n                    \"id\": id,\n                    \"field\": field if field is not None else {},\n                })\n\n            if self._mesosphere_list.qsize() &gt;= buffer_size:\n                mesosphere_list = list(self._mesosphere_list.queue)\n\n                uri = f'{self._uri}/bulk_add_items'\n                headers = {\n                    'Content-Type': 'application/msgpack'\n                }\n\n                data = {\n                    \"database_name\": self._database_name,\n                    \"collection_name\": self._collection_name,\n                    \"items\": mesosphere_list,\n                }\n\n                response = self._session.post(uri, data=None, content=pack_data(data), headers=headers)\n\n                if response.status_code == 200:\n                    self.COMMIT_FLAG = False\n                    self._mesosphere_list = queue.Queue()\n                else:\n                    raise_error_response(response)\n\n            return id\n\n    @staticmethod\n    def _check_bulk_add_items(vectors):\n        items = []\n        for vector in vectors:\n            raise_if(TypeError, not isinstance(vector, tuple), 'Each item must be a tuple of vector, '\n                                                               'ID, and fields(optional).')\n            vec_len = len(vector)\n\n            if vec_len == 3:\n                v1, v2, v3 = vector\n                items.append({\n                    \"vector\": v1.tolist() if isinstance(v1, np.ndarray) else v1,\n                    \"id\": v2,\n                    \"field\": v3,\n                })\n            elif vec_len == 2:\n                v1, v2 = vector\n                items.append({\n                    \"vector\": v1.tolist() if isinstance(v1, np.ndarray) else v1,\n                    \"id\": v2,\n                    \"field\": {},\n                })\n            else:\n                raise TypeError('Each item must be a tuple of vector, ID, and fields(optional).')\n\n        return items\n\n    def bulk_add_items(\n            self,\n            vectors: List[Union[\n                Tuple[Union[List, Tuple, np.ndarray], int, dict],\n                Tuple[Union[List, Tuple, np.ndarray], int]\n            ]],\n            batch_size: int = 1000,\n            enable_progress_bar: bool = True\n    ):\n        \"\"\"\n        Add multiple items to the collection.\n        It is recommended to use incremental ids for best performance.\n\n        Parameters:\n            vectors (List[Tuple[Union[List, Tuple, np.ndarray], int, dict]],\n            List[Tuple[Union[List, Tuple, np.ndarray], int]]):\n                The list of items to add. Each item is a tuple containing the vector, ID, and fields.\n            batch_size (int): The batch size. Default is 1000.\n            enable_progress_bar (bool): Whether to enable the progress bar. Default is True.\n\n        Returns:\n            dict: The response from the server.\n\n        Raises:\n            ValueError: If the collection has been deleted or does not exist.\n            TypeError: If the vectors are not in the correct format.\n            ExecutionError: If the server returns an error.\n        \"\"\"\n\n        uri = f'{self._uri}/bulk_add_items'\n        total_batches = (len(vectors) + batch_size - 1) // batch_size\n\n        ids = []\n\n        if enable_progress_bar:\n            iter_obj = trange(total_batches, desc='Adding items', unit='batch')\n        else:\n            iter_obj = range(total_batches)\n\n        headers = {\n            'Content-Type': 'application/msgpack',\n        }\n\n        for i in iter_obj:\n            start = i * batch_size\n            end = (i + 1) * batch_size\n            items = vectors[start:end]\n\n            items_after_checking = self._check_bulk_add_items(items)\n\n            data = {\n                \"database_name\": self._database_name,\n                \"collection_name\": self._collection_name,\n                \"items\": items_after_checking,\n            }\n\n            response = self._session.post(uri, content=pack_data(data), headers=headers)\n\n            if response.status_code == 200:\n                self.COMMIT_FLAG = False\n                ids.extend(response.json()['params']['ids'])\n            else:\n                raise_error_response(response)\n\n        return ids\n\n    def commit(self):\n        \"\"\"\n        Commit the changes in the collection.\n\n        Returns:\n            dict: The response from the server.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        uri = f'{self._uri}/commit'\n        data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name}\n\n        if not self._mesosphere_list.empty():\n            data[\"items\"] = list(self._mesosphere_list.queue)\n\n        self._mesosphere_list = queue.Queue()\n\n        response = self._session.post(uri, content=pack_data(data), headers={'Content-Type': 'application/msgpack'})\n\n        if response.status_code == 202:\n            task_id = response.json().get('task_id')\n            status_uri = f'{self._uri}/status/{task_id}'\n\n            while True:\n                status_response = self._session.get(status_uri)\n                status_data = status_response.json()\n\n                if status_response.status_code == 200:\n                    logger.info(f'Task status: {status_data}', rewrite_print=True)\n                    if status_data['status'] in ['Success', 'Error']:\n                        if status_data['status'] == 'Success':\n                            self._update_commit_msg(datetime.now().strftime('%Y-%m-%d %H:%M:%S'))\n                        else:\n                            raise_error_response(status_response)\n                        return status_data\n                else:\n                    raise_error_response(status_response)\n\n                time.sleep(2)\n        else:\n            raise_error_response(response)\n\n    def is_id_exists(self, id: int):\n        \"\"\"\n        Check if an ID exists in the collection.\n\n        Parameters:\n            id (int): The ID to check.\n\n        Returns:\n            is_id_exists(Bool): Whether the ID exists in the collection.\n        \"\"\"\n        uri = f'{self._uri}/is_id_exists'\n        data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name, \"id\": id}\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            return response.json()['params']['is_id_exists']\n        else:\n            raise_error_response(response)\n\n    @property\n    def max_id(self):\n        \"\"\"\n        Get the maximum ID in the collection.\n\n        Returns:\n            int: The maximum ID in the collection.\n        \"\"\"\n        uri = f'{self._uri}/max_id'\n        data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name}\n\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            return response.json()['params']['max_id']\n        else:\n            raise_error_response(response)\n\n    def build_index(self, index_mode: str = 'IVF-FLAT', n_clusters: int = 16):\n        \"\"\"\n        Build the index of the collection.\n\n        Parameters:\n            index_mode (str): The index mode. Default is 'IVF-FLAT'.\n            n_clusters (int): The number of clusters. Default is 16.\n\n        Returns:\n            dict: The response from the server.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        uri = f'{self._uri}/build_index'\n        data = {\n            \"database_name\": self._database_name,\n            \"collection_name\": self._collection_name,\n            \"index_mode\": index_mode,\n            \"n_clusters\": n_clusters\n        }\n\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise_error_response(response)\n\n    def remove_index(self):\n        \"\"\"\n        Remove the index of the collection.\n\n        Returns:\n            dict: The response from the server.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        uri = f'{self._uri}/remove_index'\n        data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name}\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise_error_response(response)\n\n    def insert_session(self):\n        \"\"\"\n        Start an insert session.\n        \"\"\"\n        from ...execution_layer.session import DataOpsSession\n\n        return DataOpsSession(self)\n\n    def _search(self, vector, k, search_filter, return_fields=False, **kwargs):\n        \"\"\"\n        Search the collection.\n        \"\"\"\n        uri = f'{self._uri}/search'\n\n        raise_if(ValueError, not isinstance(search_filter, (Filter, type(None), str)),\n                 'search_filter must be Filter or None or FieldExpression string.')\n\n        if isinstance(search_filter, str):\n            search_filter = ExpressionParser(search_filter).to_filter()\n\n        if search_filter is not None:\n            search_filter = search_filter.to_dict()\n\n        data = {\n            \"database_name\": self._database_name,\n            \"collection_name\": self._collection_name,\n            \"vector\": vector if isinstance(vector, list) else vector.tolist(),\n            \"k\": k,\n            \"search_filter\": search_filter,\n            \"return_fields\": return_fields,\n            **kwargs\n        }\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise_error_response(response)\n\n    def search(\n            self, vector: Union[list[float], np.ndarray], k: int = 10, *,\n            search_filter: Union[Filter, None] = None,\n            return_fields: bool = False, **kwargs\n    ):\n        \"\"\"\n        Search the database for the vectors most similar to the given vector.\n\n        Parameters:\n            vector (np.ndarray or list): The search vectors, it can be a single vector or a list of vectors.\n                The vectors must have the same dimension as the vectors in the database,\n                and the type of vector can be a list or a numpy array.\n            k (int): The number of nearest vectors to return.\n            search_filter (Filter or FilterExpression string, optional): The filter to apply to the search.\n            return_fields (bool): Whether to return the fields of the search results.\n            kwargs: Additional keyword arguments. The following are valid:\n                rescore (bool): Whether to rescore the results of binary or scaler quantization searches.\n                    Default is False. It is recommended to set it to True when the index mode is 'Binary'.\n                rescore_multiplier (int): The multiplier for the rescore operation.\n                    It is only available when rescore is True.\n                    If 'Binary' is in the index mode, the default is 10. Otherwise, the default is 2.\n\n        Returns:\n            Tuple: If return_fields is True, the indices, similarity scores,\n                    and fields of the nearest vectors in the database.\n                Otherwise, the indices and similarity scores of the nearest vectors in the database.\n\n        Raises:\n            ValueError: If the collection has been deleted or does not exist.\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        rjson = self._search(vector=vector, k=k, search_filter=search_filter, return_fields=return_fields, **kwargs)\n\n        ids, scores = (np.array(rjson['params']['items']['ids']),\n                       np.array(rjson['params']['items']['scores']))\n        fields = rjson['params']['items']['fields']\n\n        return ids, scores, fields\n\n    @property\n    def shape(self):\n        \"\"\"\n        Get the shape of the collection.\n\n        Returns:\n            Tuple: The shape of the collection.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        uri = f'{self._uri}/collection_shape'\n        data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name}\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            return tuple(response.json()['params']['shape'])\n        else:\n            rj = response.json()\n            if 'error' in rj and rj['error'] == f\"Collection '{self._collection_name}' does not exist.\":\n                return 0, self._init_params['dim']\n            else:\n                raise_error_response(response)\n\n    def head(self, n: int = 5):\n        \"\"\"\n        Get the first n items in the collection.\n\n        Parameters:\n            n (int): The number of items to return. Default is 5.\n\n        Returns:\n            Tuple: The vectors, IDs, and fields of the items.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        uri = f'{self._uri}/head'\n        data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name, \"n\": n}\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            head = response.json()['params']['head']\n            return np.asarray(head[0]), np.asarray(head[1]), head[2]\n        else:\n            raise_error_response(response)\n\n    def tail(self, n: int = 5):\n        \"\"\"\n        Get the last n items in the collection.\n\n        Parameters:\n            n (int): The number of items to return. Default is 5.\n\n        Returns:\n            Tuple: The vectors, IDs, and fields of the items.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        uri = f'{self._uri}/tail'\n        data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name, \"n\": n}\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            tail = response.json()['params']['tail']\n            return np.asarray(tail[0]), np.asarray(tail[1]), tail[2]\n        else:\n            raise_error_response(response)\n\n    def read_by_only_id(self, id: Union[int, list]):\n        \"\"\"\n        Read the item by ID.\n\n        Parameters:\n            id (int, list): The ID of the item or a list of IDs.\n\n        Returns:\n            Tuple: The vectors, IDs, and fields of the items.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        uri = f'{self._uri}/read_by_only_id'\n        data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name, \"id\": id}\n        response = self._session.post(uri, json=data)\n\n        item = response.json()['params']['item']\n\n        if response.status_code == 200:\n            return item[0], item[1], item[2]\n        else:\n            raise_error_response(response)\n\n    def query(self, query_filter, filter_ids=None, return_ids_only=False):\n        \"\"\"\n        Query the collection.\n\n        Parameters:\n            query_filter (Filter or dict): The filter object.\n            filter_ids (list[int]): The list of IDs to filter.\n            return_ids_only (bool): Whether to return the IDs only.\n\n        Returns:\n            List[dict]: The records. If not return_ids_only, the records will be returned.\n            List[int]: The external IDs. If return_ids_only, the external IDs will be returned.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n        \"\"\"\n\n        uri = f'{self._uri}/query'\n\n        raise_if(ValueError, not isinstance(query_filter, (Filter, str, type(None), dict)),\n                 'query_filter must be Filter or dict or FieldExpression string or None.')\n\n        if isinstance(query_filter, str):\n            query_filter = ExpressionParser(query_filter).to_filter()\n\n        if query_filter is not None and isinstance(query_filter, Filter):\n            query_filter = query_filter.to_dict()\n\n        data = {\n            \"database_name\": self._database_name,\n            \"collection_name\": self._collection_name,\n            \"query_filter\": query_filter,\n            \"filter_ids\": filter_ids,\n            \"return_ids_only\": return_ids_only\n        }\n\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            return response.json()['params']['result']\n        else:\n            raise_error_response(response)\n\n    def query_vectors(self, query_filter, filter_ids=None):\n        \"\"\"\n        Query the vector data by the filter.\n\n        Parameters:\n            query_filter (Filter or dict or FieldExpression str or None):\n                The filter object or the specify data to filter.\n            filter_ids (list[int]):\n                The list of external IDs to filter. Default is None.\n\n        Returns:\n            (Tuple[List[np.ndarray], List[int], List[Dict]]): The vectors, IDs, and fields of the items.\n        \"\"\"\n        uri = f'{self._uri}/query_vectors'\n\n        raise_if(ValueError, not isinstance(query_filter, (Filter, str, type(None), dict)),\n                 'query_filter must be Filter or dict or FieldExpression string or None.')\n\n        if isinstance(query_filter, str):\n            query_filter = ExpressionParser(query_filter).to_filter()\n\n        if query_filter is not None and isinstance(query_filter, Filter):\n            query_filter = query_filter.to_dict()\n\n        data = {\n            \"database_name\": self._database_name,\n            \"collection_name\": self._collection_name,\n            \"query_filter\": query_filter,\n            \"filter_ids\": filter_ids,\n        }\n\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            result = response.json()['params']['result']\n            return np.asarray(result[0]), np.array(result[1]), result[2]\n        else:\n            raise_error_response(response)\n\n    def build_field_index(self, schema, rebuild_if_exists=False):\n        \"\"\"\n        Build the field index of the collection.\n\n        Parameters:\n            schema (IndexSchema): The schema of the field index.\n            rebuild_if_exists (bool): Whether to rebuild the field index if it exists.\n\n        Returns:\n            dict: The response from the server.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        if not isinstance(schema, IndexSchema):\n            raise TypeError(\"schema must be an instance of IndexSchema.\")\n\n        uri = f'{self._uri}/build_field_index'\n        data = {\n            \"database_name\": self._database_name,\n            \"collection_name\": self._collection_name,\n            \"schema\": schema.to_dict(),\n            \"rebuild_if_exists\": rebuild_if_exists\n        }\n\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise_error_response(response)\n\n    def list_field_index(self):\n        \"\"\"\n        List the field index of the collection.\n\n        Returns:\n            dict: The field index of the collection.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        uri = f'{self._uri}/list_field_index'\n        data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name}\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            return response.json()['params']['field_indices']\n        else:\n            raise_error_response(response)\n\n    def remove_field_index(self, field_name):\n        \"\"\"\n        Remove the field index of the collection.\n\n        Parameters:\n            field_name (str): The name of the field.\n\n        Returns:\n            dict: The response from the server.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        uri = f'{self._uri}/remove_field_index'\n        data = {\n            \"database_name\": self._database_name,\n            \"collection_name\": self._collection_name,\n            \"field_name\": field_name\n        }\n\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise_error_response(response)\n\n    def remove_all_field_indices(self):\n        \"\"\"\n        Remove all the field indices of the collection.\n\n        Returns:\n            dict: The response from the server.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        uri = f'{self._uri}/remove_all_field_indices'\n        data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name}\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise_error_response(response)\n\n    def list_fields(self):\n        \"\"\"\n        List all fields of a collection.\n\n        Returns:\n            dict: The status of the operation.\n        \"\"\"\n        uri = f'{self._uri}/list_fields'\n        data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name}\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            return response.json()['params']['fields']\n        else:\n            raise_error_response(response)\n\n    def update_description(self, description: str):\n        \"\"\"\n        Update the description of the collection.\n\n        Parameters:\n            description (str): The description of the collection.\n\n        Returns:\n            dict: The response from the server.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        uri = f'{self._uri}/update_description'\n        data = {\n            \"database_name\": self._database_name,\n            \"collection_name\": self._collection_name,\n            \"description\": description\n        }\n\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise_error_response(response)\n\n    def get_collection_path(self):\n        \"\"\"\n        Get the path of the database.\n\n        Returns:\n            str: The path of the database.\n        \"\"\"\n        uri = f'{self._uri}/get_collection_path'\n        data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name}\n\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            return response.json()['params']['collection_path']\n        else:\n            raise_error_response(response)\n\n    @property\n    def index_mode(self):\n        \"\"\"\n        Get the index mode of the collection.\n\n        Returns:\n            str: The index mode of the collection.\n        \"\"\"\n        uri = f'{self._uri}/index_mode'\n        data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name}\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            return response.json()['params']['index_mode']\n        else:\n            raise_error_response(response)\n\n    def __repr__(self):\n        return collection_repr(self)\n\n    def __str__(self):\n        return self.__repr__()\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.index_mode","title":"<code>index_mode</code>  <code>property</code>","text":"<p>Get the index mode of the collection.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The index mode of the collection.</p>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.max_id","title":"<code>max_id</code>  <code>property</code>","text":"<p>Get the maximum ID in the collection.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The maximum ID in the collection.</p>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Get the shape of the collection.</p> <p>Returns:</p> Name Type Description <code>Tuple</code> <p>The shape of the collection.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If the server returns an error.</p>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.__init__","title":"<code>__init__(uri, database_name, collection_name, **params)</code>","text":"<p>Initialize the collection.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The URI of the server.</p> required <code>database_name</code> <code>str</code> <p>The name of the database.</p> required <code>collection_name</code> <code>str</code> <p>The name of the collection.</p> required <code>**params</code> <p>The collection parameters. - dim (int): The dimension of the vectors. - chunk_size (int): The chunk size. - dtypes (str): The data types. - use_cache (bool): Whether to use cache. - n_threads (int): The number of threads. - warm_up (bool): Whether to warm up. - drop_if_exists (bool): Whether to drop the collection if it exists. - cache_chunks (int): The number of chunks to cache.</p> <code>{}</code> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def __init__(self, uri, database_name, collection_name, **params):\n    \"\"\"\n    Initialize the collection.\n\n    Parameters:\n        uri (str): The URI of the server.\n        database_name (str): The name of the database.\n        collection_name (str): The name of the collection.\n        **params: The collection parameters.\n            - dim (int): The dimension of the vectors.\n            - chunk_size (int): The chunk size.\n            - dtypes (str): The data types.\n            - use_cache (bool): Whether to use cache.\n            - n_threads (int): The number of threads.\n            - warm_up (bool): Whether to warm up.\n            - drop_if_exists (bool): Whether to drop the collection if it exists.\n            - cache_chunks (int): The number of chunks to cache.\n\n    \"\"\"\n    self.IS_DELETED = False\n    self._uri = uri\n    self._database_name = database_name\n    self._collection_name = collection_name\n    self._session = Poster()\n    self._init_params = params\n\n    self.COMMIT_FLAG = False\n\n    self._mesosphere_list = queue.Queue()\n    self._lock = ThreadLock()\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.add_item","title":"<code>add_item(vector, id, *, field=None, buffer_size=True)</code>","text":"<p>Add an item to the collection. It is recommended to use incremental ids for best performance.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>(list[float], ndarray)</code> <p>The vector of the item.</p> required <code>id</code> <code>int</code> <p>The ID of the item.</p> required <code>field</code> <code>dict</code> <p>The fields of the item.</p> <code>None</code> <code>buffer_size</code> <code>int or bool</code> <p>The buffer size. Default is True, which means the default buffer size (1000) will be used. If buffer_size is 0, the function will add the item directly. If buffer_size is greater than 0, the function will add the item to the buffer. If buffer_size is False, the function will add the item directly and not use the buffer. If buffer_size is True, the function will add the item to the buffer and use the default buffer size.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>int</code> <p>The ID of the item. If delay_num is greater than 0, and the number of items added is less than delay_num, the function will return None. Otherwise, the function will return the IDs of the items added.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the collection has been deleted or does not exist.</p> <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def add_item(self, vector: Union[list[float], np.ndarray], id: int, *, field: Union[dict, None] = None,\n             buffer_size: int = True):\n    \"\"\"\n    Add an item to the collection.\n    It is recommended to use incremental ids for best performance.\n\n    Parameters:\n        vector (list[float], np.ndarray): The vector of the item.\n        id (int): The ID of the item.\n        field (dict, optional): The fields of the item.\n        buffer_size (int or bool): The buffer size.\n            Default is True, which means the default buffer size (1000) will be used.\n            If buffer_size is 0, the function will add the item directly.\n            If buffer_size is greater than 0, the function will add the item to the buffer.\n            If buffer_size is False, the function will add the item directly and not use the buffer.\n            If buffer_size is True, the function will add the item to the buffer and use the default buffer size.\n\n    Returns:\n        int: The ID of the item.\n            If delay_num is greater than 0, and the number of items added is less than delay_num,\n            the function will return None. Otherwise, the function will return the IDs of the items added.\n\n    Raises:\n        ValueError: If the collection has been deleted or does not exist.\n        ExecutionError: If the server returns an error.\n    \"\"\"\n    if buffer_size is True:\n        buffer_size = 1000\n    else:\n        if buffer_size is False:\n            buffer_size = 0\n        else:\n            raise_if(ValueError, (not isinstance(buffer_size, int)) or buffer_size &lt; 0,\n                     'If buffer_size is not bool, it must be a positive integer.')\n\n    if buffer_size == 0:\n        uri = f'{self._uri}/add_item'\n        headers = {\n            'Content-Type': 'application/msgpack'\n        }\n\n        data = {\n            \"database_name\": self._database_name,\n            \"collection_name\": self._collection_name,\n            \"item\": {\n                \"vector\": vector if isinstance(vector, list) else vector.tolist(),\n                \"id\": id,\n                \"field\": field if field is not None else {},\n            },\n        }\n\n        response = self._session.post(uri, data=None, content=pack_data(data), headers=headers)\n\n        if response.status_code == 200:\n            self.COMMIT_FLAG = False\n            return response.json()['params']['item']['id']\n        else:\n            raise_error_response(response)\n    else:\n        with self._lock:\n            self._mesosphere_list.put({\n                \"vector\": vector if isinstance(vector, list) else vector.tolist(),\n                \"id\": id,\n                \"field\": field if field is not None else {},\n            })\n\n        if self._mesosphere_list.qsize() &gt;= buffer_size:\n            mesosphere_list = list(self._mesosphere_list.queue)\n\n            uri = f'{self._uri}/bulk_add_items'\n            headers = {\n                'Content-Type': 'application/msgpack'\n            }\n\n            data = {\n                \"database_name\": self._database_name,\n                \"collection_name\": self._collection_name,\n                \"items\": mesosphere_list,\n            }\n\n            response = self._session.post(uri, data=None, content=pack_data(data), headers=headers)\n\n            if response.status_code == 200:\n                self.COMMIT_FLAG = False\n                self._mesosphere_list = queue.Queue()\n            else:\n                raise_error_response(response)\n\n        return id\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.build_field_index","title":"<code>build_field_index(schema, rebuild_if_exists=False)</code>","text":"<p>Build the field index of the collection.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>IndexSchema</code> <p>The schema of the field index.</p> required <code>rebuild_if_exists</code> <code>bool</code> <p>Whether to rebuild the field index if it exists.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the server.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def build_field_index(self, schema, rebuild_if_exists=False):\n    \"\"\"\n    Build the field index of the collection.\n\n    Parameters:\n        schema (IndexSchema): The schema of the field index.\n        rebuild_if_exists (bool): Whether to rebuild the field index if it exists.\n\n    Returns:\n        dict: The response from the server.\n\n    Raises:\n        ExecutionError: If the server returns an error.\n    \"\"\"\n    if not isinstance(schema, IndexSchema):\n        raise TypeError(\"schema must be an instance of IndexSchema.\")\n\n    uri = f'{self._uri}/build_field_index'\n    data = {\n        \"database_name\": self._database_name,\n        \"collection_name\": self._collection_name,\n        \"schema\": schema.to_dict(),\n        \"rebuild_if_exists\": rebuild_if_exists\n    }\n\n    response = self._session.post(uri, json=data)\n\n    if response.status_code == 200:\n        return response.json()\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.build_index","title":"<code>build_index(index_mode='IVF-FLAT', n_clusters=16)</code>","text":"<p>Build the index of the collection.</p> <p>Parameters:</p> Name Type Description Default <code>index_mode</code> <code>str</code> <p>The index mode. Default is 'IVF-FLAT'.</p> <code>'IVF-FLAT'</code> <code>n_clusters</code> <code>int</code> <p>The number of clusters. Default is 16.</p> <code>16</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the server.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def build_index(self, index_mode: str = 'IVF-FLAT', n_clusters: int = 16):\n    \"\"\"\n    Build the index of the collection.\n\n    Parameters:\n        index_mode (str): The index mode. Default is 'IVF-FLAT'.\n        n_clusters (int): The number of clusters. Default is 16.\n\n    Returns:\n        dict: The response from the server.\n\n    Raises:\n        ExecutionError: If the server returns an error.\n    \"\"\"\n    uri = f'{self._uri}/build_index'\n    data = {\n        \"database_name\": self._database_name,\n        \"collection_name\": self._collection_name,\n        \"index_mode\": index_mode,\n        \"n_clusters\": n_clusters\n    }\n\n    response = self._session.post(uri, json=data)\n\n    if response.status_code == 200:\n        return response.json()\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.bulk_add_items","title":"<code>bulk_add_items(vectors, batch_size=1000, enable_progress_bar=True)</code>","text":"<p>Add multiple items to the collection. It is recommended to use incremental ids for best performance.</p> <p>Parameters:</p> Name Type Description Default <code>List[Tuple[Union[List,</code> <code>Tuple, np.ndarray], int]]</code> <p>The list of items to add. Each item is a tuple containing the vector, ID, and fields.</p> required <code>batch_size</code> <code>int</code> <p>The batch size. Default is 1000.</p> <code>1000</code> <code>enable_progress_bar</code> <code>bool</code> <p>Whether to enable the progress bar. Default is True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the server.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the collection has been deleted or does not exist.</p> <code>TypeError</code> <p>If the vectors are not in the correct format.</p> <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def bulk_add_items(\n        self,\n        vectors: List[Union[\n            Tuple[Union[List, Tuple, np.ndarray], int, dict],\n            Tuple[Union[List, Tuple, np.ndarray], int]\n        ]],\n        batch_size: int = 1000,\n        enable_progress_bar: bool = True\n):\n    \"\"\"\n    Add multiple items to the collection.\n    It is recommended to use incremental ids for best performance.\n\n    Parameters:\n        vectors (List[Tuple[Union[List, Tuple, np.ndarray], int, dict]],\n        List[Tuple[Union[List, Tuple, np.ndarray], int]]):\n            The list of items to add. Each item is a tuple containing the vector, ID, and fields.\n        batch_size (int): The batch size. Default is 1000.\n        enable_progress_bar (bool): Whether to enable the progress bar. Default is True.\n\n    Returns:\n        dict: The response from the server.\n\n    Raises:\n        ValueError: If the collection has been deleted or does not exist.\n        TypeError: If the vectors are not in the correct format.\n        ExecutionError: If the server returns an error.\n    \"\"\"\n\n    uri = f'{self._uri}/bulk_add_items'\n    total_batches = (len(vectors) + batch_size - 1) // batch_size\n\n    ids = []\n\n    if enable_progress_bar:\n        iter_obj = trange(total_batches, desc='Adding items', unit='batch')\n    else:\n        iter_obj = range(total_batches)\n\n    headers = {\n        'Content-Type': 'application/msgpack',\n    }\n\n    for i in iter_obj:\n        start = i * batch_size\n        end = (i + 1) * batch_size\n        items = vectors[start:end]\n\n        items_after_checking = self._check_bulk_add_items(items)\n\n        data = {\n            \"database_name\": self._database_name,\n            \"collection_name\": self._collection_name,\n            \"items\": items_after_checking,\n        }\n\n        response = self._session.post(uri, content=pack_data(data), headers=headers)\n\n        if response.status_code == 200:\n            self.COMMIT_FLAG = False\n            ids.extend(response.json()['params']['ids'])\n        else:\n            raise_error_response(response)\n\n    return ids\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.commit","title":"<code>commit()</code>","text":"<p>Commit the changes in the collection.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the server.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def commit(self):\n    \"\"\"\n    Commit the changes in the collection.\n\n    Returns:\n        dict: The response from the server.\n\n    Raises:\n        ExecutionError: If the server returns an error.\n    \"\"\"\n    uri = f'{self._uri}/commit'\n    data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name}\n\n    if not self._mesosphere_list.empty():\n        data[\"items\"] = list(self._mesosphere_list.queue)\n\n    self._mesosphere_list = queue.Queue()\n\n    response = self._session.post(uri, content=pack_data(data), headers={'Content-Type': 'application/msgpack'})\n\n    if response.status_code == 202:\n        task_id = response.json().get('task_id')\n        status_uri = f'{self._uri}/status/{task_id}'\n\n        while True:\n            status_response = self._session.get(status_uri)\n            status_data = status_response.json()\n\n            if status_response.status_code == 200:\n                logger.info(f'Task status: {status_data}', rewrite_print=True)\n                if status_data['status'] in ['Success', 'Error']:\n                    if status_data['status'] == 'Success':\n                        self._update_commit_msg(datetime.now().strftime('%Y-%m-%d %H:%M:%S'))\n                    else:\n                        raise_error_response(status_response)\n                    return status_data\n            else:\n                raise_error_response(status_response)\n\n            time.sleep(2)\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.exists","title":"<code>exists()</code>","text":"<p>Check if the collection exists.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>Whether the collection exists.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def exists(self):\n    \"\"\"\n    Check if the collection exists.\n\n    Returns:\n        bool: Whether the collection exists.\n\n    Raises:\n        ExecutionError: If the server returns an error.\n\n    \"\"\"\n    uri = f'{self._uri}/is_collection_exists'\n    data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name}\n\n    response = self._session.post(uri, json=data)\n\n    if response.status_code == 200:\n        return response.json()['params']['exists']\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.get_collection_path","title":"<code>get_collection_path()</code>","text":"<p>Get the path of the database.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The path of the database.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def get_collection_path(self):\n    \"\"\"\n    Get the path of the database.\n\n    Returns:\n        str: The path of the database.\n    \"\"\"\n    uri = f'{self._uri}/get_collection_path'\n    data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name}\n\n    response = self._session.post(uri, json=data)\n\n    if response.status_code == 200:\n        return response.json()['params']['collection_path']\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.head","title":"<code>head(n=5)</code>","text":"<p>Get the first n items in the collection.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of items to return. Default is 5.</p> <code>5</code> <p>Returns:</p> Name Type Description <code>Tuple</code> <p>The vectors, IDs, and fields of the items.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def head(self, n: int = 5):\n    \"\"\"\n    Get the first n items in the collection.\n\n    Parameters:\n        n (int): The number of items to return. Default is 5.\n\n    Returns:\n        Tuple: The vectors, IDs, and fields of the items.\n\n    Raises:\n        ExecutionError: If the server returns an error.\n    \"\"\"\n    uri = f'{self._uri}/head'\n    data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name, \"n\": n}\n    response = self._session.post(uri, json=data)\n\n    if response.status_code == 200:\n        head = response.json()['params']['head']\n        return np.asarray(head[0]), np.asarray(head[1]), head[2]\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.insert_session","title":"<code>insert_session()</code>","text":"<p>Start an insert session.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def insert_session(self):\n    \"\"\"\n    Start an insert session.\n    \"\"\"\n    from ...execution_layer.session import DataOpsSession\n\n    return DataOpsSession(self)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.is_id_exists","title":"<code>is_id_exists(id)</code>","text":"<p>Check if an ID exists in the collection.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID to check.</p> required <p>Returns:</p> Name Type Description <code>is_id_exists</code> <code>Bool</code> <p>Whether the ID exists in the collection.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def is_id_exists(self, id: int):\n    \"\"\"\n    Check if an ID exists in the collection.\n\n    Parameters:\n        id (int): The ID to check.\n\n    Returns:\n        is_id_exists(Bool): Whether the ID exists in the collection.\n    \"\"\"\n    uri = f'{self._uri}/is_id_exists'\n    data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name, \"id\": id}\n    response = self._session.post(uri, json=data)\n\n    if response.status_code == 200:\n        return response.json()['params']['is_id_exists']\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.list_field_index","title":"<code>list_field_index()</code>","text":"<p>List the field index of the collection.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The field index of the collection.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def list_field_index(self):\n    \"\"\"\n    List the field index of the collection.\n\n    Returns:\n        dict: The field index of the collection.\n\n    Raises:\n        ExecutionError: If the server returns an error.\n    \"\"\"\n    uri = f'{self._uri}/list_field_index'\n    data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name}\n    response = self._session.post(uri, json=data)\n\n    if response.status_code == 200:\n        return response.json()['params']['field_indices']\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.list_fields","title":"<code>list_fields()</code>","text":"<p>List all fields of a collection.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def list_fields(self):\n    \"\"\"\n    List all fields of a collection.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    uri = f'{self._uri}/list_fields'\n    data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name}\n    response = self._session.post(uri, json=data)\n\n    if response.status_code == 200:\n        return response.json()['params']['fields']\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.query","title":"<code>query(query_filter, filter_ids=None, return_ids_only=False)</code>","text":"<p>Query the collection.</p> <p>Parameters:</p> Name Type Description Default <code>query_filter</code> <code>Filter or dict</code> <p>The filter object.</p> required <code>filter_ids</code> <code>list[int]</code> <p>The list of IDs to filter.</p> <code>None</code> <code>return_ids_only</code> <code>bool</code> <p>Whether to return the IDs only.</p> <code>False</code> <p>Returns:</p> Type Description <p>List[dict]: The records. If not return_ids_only, the records will be returned.</p> <p>List[int]: The external IDs. If return_ids_only, the external IDs will be returned.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def query(self, query_filter, filter_ids=None, return_ids_only=False):\n    \"\"\"\n    Query the collection.\n\n    Parameters:\n        query_filter (Filter or dict): The filter object.\n        filter_ids (list[int]): The list of IDs to filter.\n        return_ids_only (bool): Whether to return the IDs only.\n\n    Returns:\n        List[dict]: The records. If not return_ids_only, the records will be returned.\n        List[int]: The external IDs. If return_ids_only, the external IDs will be returned.\n\n    Raises:\n        ExecutionError: If the server returns an error.\n    \"\"\"\n\n    uri = f'{self._uri}/query'\n\n    raise_if(ValueError, not isinstance(query_filter, (Filter, str, type(None), dict)),\n             'query_filter must be Filter or dict or FieldExpression string or None.')\n\n    if isinstance(query_filter, str):\n        query_filter = ExpressionParser(query_filter).to_filter()\n\n    if query_filter is not None and isinstance(query_filter, Filter):\n        query_filter = query_filter.to_dict()\n\n    data = {\n        \"database_name\": self._database_name,\n        \"collection_name\": self._collection_name,\n        \"query_filter\": query_filter,\n        \"filter_ids\": filter_ids,\n        \"return_ids_only\": return_ids_only\n    }\n\n    response = self._session.post(uri, json=data)\n\n    if response.status_code == 200:\n        return response.json()['params']['result']\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.query_vectors","title":"<code>query_vectors(query_filter, filter_ids=None)</code>","text":"<p>Query the vector data by the filter.</p> <p>Parameters:</p> Name Type Description Default <code>query_filter</code> <code>Filter or dict or FieldExpression str or None</code> <p>The filter object or the specify data to filter.</p> required <code>filter_ids</code> <code>list[int]</code> <p>The list of external IDs to filter. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[List[ndarray], List[int], List[Dict]]</code> <p>The vectors, IDs, and fields of the items.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def query_vectors(self, query_filter, filter_ids=None):\n    \"\"\"\n    Query the vector data by the filter.\n\n    Parameters:\n        query_filter (Filter or dict or FieldExpression str or None):\n            The filter object or the specify data to filter.\n        filter_ids (list[int]):\n            The list of external IDs to filter. Default is None.\n\n    Returns:\n        (Tuple[List[np.ndarray], List[int], List[Dict]]): The vectors, IDs, and fields of the items.\n    \"\"\"\n    uri = f'{self._uri}/query_vectors'\n\n    raise_if(ValueError, not isinstance(query_filter, (Filter, str, type(None), dict)),\n             'query_filter must be Filter or dict or FieldExpression string or None.')\n\n    if isinstance(query_filter, str):\n        query_filter = ExpressionParser(query_filter).to_filter()\n\n    if query_filter is not None and isinstance(query_filter, Filter):\n        query_filter = query_filter.to_dict()\n\n    data = {\n        \"database_name\": self._database_name,\n        \"collection_name\": self._collection_name,\n        \"query_filter\": query_filter,\n        \"filter_ids\": filter_ids,\n    }\n\n    response = self._session.post(uri, json=data)\n\n    if response.status_code == 200:\n        result = response.json()['params']['result']\n        return np.asarray(result[0]), np.array(result[1]), result[2]\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.read_by_only_id","title":"<code>read_by_only_id(id)</code>","text":"<p>Read the item by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>(int, list)</code> <p>The ID of the item or a list of IDs.</p> required <p>Returns:</p> Name Type Description <code>Tuple</code> <p>The vectors, IDs, and fields of the items.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def read_by_only_id(self, id: Union[int, list]):\n    \"\"\"\n    Read the item by ID.\n\n    Parameters:\n        id (int, list): The ID of the item or a list of IDs.\n\n    Returns:\n        Tuple: The vectors, IDs, and fields of the items.\n\n    Raises:\n        ExecutionError: If the server returns an error.\n    \"\"\"\n    uri = f'{self._uri}/read_by_only_id'\n    data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name, \"id\": id}\n    response = self._session.post(uri, json=data)\n\n    item = response.json()['params']['item']\n\n    if response.status_code == 200:\n        return item[0], item[1], item[2]\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.remove_all_field_indices","title":"<code>remove_all_field_indices()</code>","text":"<p>Remove all the field indices of the collection.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the server.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def remove_all_field_indices(self):\n    \"\"\"\n    Remove all the field indices of the collection.\n\n    Returns:\n        dict: The response from the server.\n\n    Raises:\n        ExecutionError: If the server returns an error.\n    \"\"\"\n    uri = f'{self._uri}/remove_all_field_indices'\n    data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name}\n    response = self._session.post(uri, json=data)\n\n    if response.status_code == 200:\n        return response.json()\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.remove_field_index","title":"<code>remove_field_index(field_name)</code>","text":"<p>Remove the field index of the collection.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the field.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the server.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def remove_field_index(self, field_name):\n    \"\"\"\n    Remove the field index of the collection.\n\n    Parameters:\n        field_name (str): The name of the field.\n\n    Returns:\n        dict: The response from the server.\n\n    Raises:\n        ExecutionError: If the server returns an error.\n    \"\"\"\n    uri = f'{self._uri}/remove_field_index'\n    data = {\n        \"database_name\": self._database_name,\n        \"collection_name\": self._collection_name,\n        \"field_name\": field_name\n    }\n\n    response = self._session.post(uri, json=data)\n\n    if response.status_code == 200:\n        return response.json()\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.remove_index","title":"<code>remove_index()</code>","text":"<p>Remove the index of the collection.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the server.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def remove_index(self):\n    \"\"\"\n    Remove the index of the collection.\n\n    Returns:\n        dict: The response from the server.\n\n    Raises:\n        ExecutionError: If the server returns an error.\n    \"\"\"\n    uri = f'{self._uri}/remove_index'\n    data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name}\n    response = self._session.post(uri, json=data)\n\n    if response.status_code == 200:\n        return response.json()\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.search","title":"<code>search(vector, k=10, *, search_filter=None, return_fields=False, **kwargs)</code>","text":"<p>Search the database for the vectors most similar to the given vector.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>ndarray or list</code> <p>The search vectors, it can be a single vector or a list of vectors. The vectors must have the same dimension as the vectors in the database, and the type of vector can be a list or a numpy array.</p> required <code>k</code> <code>int</code> <p>The number of nearest vectors to return.</p> <code>10</code> <code>search_filter</code> <code>Filter or FilterExpression string</code> <p>The filter to apply to the search.</p> <code>None</code> <code>return_fields</code> <code>bool</code> <p>Whether to return the fields of the search results.</p> <code>False</code> <code>kwargs</code> <p>Additional keyword arguments. The following are valid: rescore (bool): Whether to rescore the results of binary or scaler quantization searches.     Default is False. It is recommended to set it to True when the index mode is 'Binary'. rescore_multiplier (int): The multiplier for the rescore operation.     It is only available when rescore is True.     If 'Binary' is in the index mode, the default is 10. Otherwise, the default is 2.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Tuple</code> <p>If return_fields is True, the indices, similarity scores,     and fields of the nearest vectors in the database. Otherwise, the indices and similarity scores of the nearest vectors in the database.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the collection has been deleted or does not exist.</p> <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def search(\n        self, vector: Union[list[float], np.ndarray], k: int = 10, *,\n        search_filter: Union[Filter, None] = None,\n        return_fields: bool = False, **kwargs\n):\n    \"\"\"\n    Search the database for the vectors most similar to the given vector.\n\n    Parameters:\n        vector (np.ndarray or list): The search vectors, it can be a single vector or a list of vectors.\n            The vectors must have the same dimension as the vectors in the database,\n            and the type of vector can be a list or a numpy array.\n        k (int): The number of nearest vectors to return.\n        search_filter (Filter or FilterExpression string, optional): The filter to apply to the search.\n        return_fields (bool): Whether to return the fields of the search results.\n        kwargs: Additional keyword arguments. The following are valid:\n            rescore (bool): Whether to rescore the results of binary or scaler quantization searches.\n                Default is False. It is recommended to set it to True when the index mode is 'Binary'.\n            rescore_multiplier (int): The multiplier for the rescore operation.\n                It is only available when rescore is True.\n                If 'Binary' is in the index mode, the default is 10. Otherwise, the default is 2.\n\n    Returns:\n        Tuple: If return_fields is True, the indices, similarity scores,\n                and fields of the nearest vectors in the database.\n            Otherwise, the indices and similarity scores of the nearest vectors in the database.\n\n    Raises:\n        ValueError: If the collection has been deleted or does not exist.\n        ExecutionError: If the server returns an error.\n    \"\"\"\n    rjson = self._search(vector=vector, k=k, search_filter=search_filter, return_fields=return_fields, **kwargs)\n\n    ids, scores = (np.array(rjson['params']['items']['ids']),\n                   np.array(rjson['params']['items']['scores']))\n    fields = rjson['params']['items']['fields']\n\n    return ids, scores, fields\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.tail","title":"<code>tail(n=5)</code>","text":"<p>Get the last n items in the collection.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of items to return. Default is 5.</p> <code>5</code> <p>Returns:</p> Name Type Description <code>Tuple</code> <p>The vectors, IDs, and fields of the items.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def tail(self, n: int = 5):\n    \"\"\"\n    Get the last n items in the collection.\n\n    Parameters:\n        n (int): The number of items to return. Default is 5.\n\n    Returns:\n        Tuple: The vectors, IDs, and fields of the items.\n\n    Raises:\n        ExecutionError: If the server returns an error.\n    \"\"\"\n    uri = f'{self._uri}/tail'\n    data = {\"database_name\": self._database_name, \"collection_name\": self._collection_name, \"n\": n}\n    response = self._session.post(uri, json=data)\n\n    if response.status_code == 200:\n        tail = response.json()['params']['tail']\n        return np.asarray(tail[0]), np.asarray(tail[1]), tail[2]\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.Collection.update_description","title":"<code>update_description(description)</code>","text":"<p>Update the description of the collection.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>The description of the collection.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the server.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def update_description(self, description: str):\n    \"\"\"\n    Update the description of the collection.\n\n    Parameters:\n        description (str): The description of the collection.\n\n    Returns:\n        dict: The response from the server.\n\n    Raises:\n        ExecutionError: If the server returns an error.\n    \"\"\"\n    uri = f'{self._uri}/update_description'\n    data = {\n        \"database_name\": self._database_name,\n        \"collection_name\": self._collection_name,\n        \"description\": description\n    }\n\n    response = self._session.post(uri, json=data)\n\n    if response.status_code == 200:\n        return response.json()\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.HTTPClient","title":"<code>HTTPClient</code>","text":"<p>The HTTPClient class is used to interact with the LynseDB server.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>class HTTPClient:\n    \"\"\"\n    The HTTPClient class is used to interact with the LynseDB server.\n    \"\"\"\n    def __init__(self, uri, database_name):\n        \"\"\"\n        Initialize the client.\n\n        Parameters:\n            uri (str): The URI of the server, must start with \"http://\" or \"https://\".\n            database_name (str): The name of the database.\n\n        Raises:\n            TypeError: If the URI is not a string.\n            ValueError: If the URI does not start with \"http://\" or \"https://\".\n            ConnectionError: If the server cannot be connected to.\n        \"\"\"\n\n        raise_if(TypeError, not isinstance(uri, str), 'The URI must be a string.')\n        raise_if(ValueError, not uri.startswith('http://') or uri.startswith('https://'),\n                 'The URI must start with \"http://\" or \"https://\".')\n\n        self._session = httpx.Client()\n\n        if uri.endswith('/'):\n            self.uri = uri[:-1]\n        else:\n            self.uri = uri\n\n        self.database_name = database_name\n\n    def require_collection(\n            self,\n            collection: str,\n            dim: int = None,\n            chunk_size: int = 100_000,\n            dtypes: str = 'float32',\n            use_cache: bool = True,\n            n_threads: Union[int, None] = 10,\n            warm_up: bool = False,\n            drop_if_exists: bool = False,\n            description: str = None,\n            cache_chunks: int = 20\n    ):\n        \"\"\"\n        Create a collection.\n\n        Parameters:\n            collection (str): The name of the collection.\n            dim (int): The dimension of the vectors. Default is None.\n                When creating a new collection, the dimension of the vectors must be specified.\n                When loading an existing collection, the dimension of the vectors is automatically loaded.\n            chunk_size (int): The chunk size. Default is 100,000.\n            dtypes (str): The data types. Default is 'float32'.\n            use_cache (bool): Whether to use cache for search. Default is True.\n            n_threads (int): The number of threads. Default is 10.\n            warm_up (bool): Whether to warm up. Default is False.\n            drop_if_exists (bool): Whether to drop the collection if it exists. Default is False.\n            description (str): A description of the collection. Default is None.\n                The description is limited to 500 characters.\n            cache_chunks (int): The number of chunks to cache in memory. Default is 20.\n\n        Returns:\n            Collection: The collection object.\n\n        Raises:\n            ConnectionError: If the server cannot be connected to.\n        \"\"\"\n        uri = f'{self.uri}/required_collection'\n\n        data = {\n            \"database_name\": self.database_name,\n            \"collection_name\": collection,\n            \"dim\": dim,\n            \"chunk_size\": chunk_size,\n            \"dtypes\": dtypes,\n            \"use_cache\": use_cache,\n            \"n_threads\": n_threads,\n            \"warm_up\": warm_up,\n            \"drop_if_exists\": drop_if_exists,\n            \"description\": description,\n            \"cache_chunks\": cache_chunks\n        }\n\n        try:\n            response = self._session.post(uri, json=data)\n            if response.status_code == 200:\n                del data['collection_name']\n                del data['database_name']\n                collection = Collection(uri=self.uri, database_name=self.database_name,\n                                        collection_name=collection, **data)\n                return collection\n            else:\n                raise_error_response(response)\n        except httpx.RequestError:\n            raise ConnectionError(f'Failed to connect to the server at {uri}.')\n\n    def get_collection(self, collection: str, cache_chunks=20, warm_up=True):\n        \"\"\"\n        Get a collection.\n\n        Parameters:\n            collection (str): The name of the collection.\n            cache_chunks (int): The number of chunks to cache. Default is 20.\n            warm_up (bool): Whether to warm up. Default is True.\n\n        Returns:\n            Collection: The collection object.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        uri = f'{self.uri}/is_collection_exists'\n        data = {\"database_name\": self.database_name, \"collection_name\": collection}\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200 and response.json()['params']['exists']:\n            uri = f'{self.uri}/get_collection_config'\n            data = {\"database_name\": self.database_name, \"collection_name\": collection}\n            response = self._session.post(uri, json=data)\n\n            params = response.json()['params']['config']\n            params.update({'cache_chunks': cache_chunks, 'warm_up': warm_up})\n\n            return Collection(uri=self.uri, database_name=self.database_name, collection_name=collection,\n                              **params)\n        else:\n            raise_error_response(response)\n\n    def drop_collection(self, collection: str):\n        \"\"\"\n        Drop a collection.\n\n        Parameters:\n            collection (str): The name of the collection.\n\n        Returns:\n            dict: The response from the server.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        try:\n            _ = self.get_collection(collection)\n        except ExecutionError:\n            pass\n\n        uri = f'{self.uri}/drop_collection'\n        data = {\"database_name\": self.database_name, \"collection_name\": collection}\n        return self._session.post(uri, json=data).json()\n\n    def drop_database(self):\n        \"\"\"\n        Drop the database.\n\n        Returns:\n            dict: The response from the server.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        if not self.database_exists()['params']['exists']:\n            return {'status': 'success', 'message': 'The database does not exist.'}\n\n        uri = f'{self.uri}/drop_database'\n        data = {\"database_name\": self.database_name}\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise_error_response(response)\n\n    def database_exists(self):\n        \"\"\"\n        Check if the database exists.\n\n        Returns:\n            dict: The response from the server.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        uri = f'{self.uri}/database_exists'\n        data = {\"database_name\": self.database_name}\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise_error_response(response)\n\n    def show_collections(self):\n        \"\"\"\n        Show all collections in the database.\n\n        Returns:\n            List: The list of collections.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        uri = f'{self.uri}/show_collections'\n        data = {\"database_name\": self.database_name}\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            return response.json()['params']['collections']\n        else:\n            raise_error_response(response)\n\n    def set_environment(self, env: dict):\n        \"\"\"\n        Set the environment variables.\n\n        Parameters:\n            env (dict): The environment variables. It can be specified on the same time or separately.\n                - LYNSE_LOG_LEVEL: The log level.\n                - LYNSE_LOG_PATH: The log path.\n                - LYNSE_TRUNCATE_LOG: Whether to truncate the log.\n                - LYNSE_LOG_WITH_TIME: Whether to log with time.\n                - LYNSE_KMEANS_EPOCHS: The number of epochs for KMeans.\n                - LYNSE_SEARCH_CACHE_SIZE: The search cache size.\n                - LYNSE_DATALOADER_BUFFER_SIZE: The dataloader buffer size.\n\n        Returns:\n            dict: The response from the server.\n\n        Raises:\n            TypeError: If the value of an environment variable is not a string.\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        uri = f'{self.uri}/set_environment'\n\n        env_list = ['LYNSE_LOG_LEVEL', 'LYNSE_LOG_PATH', 'LYNSE_TRUNCATE_LOG', 'LYNSE_LOG_WITH_TIME',\n                    'LYNSE_KMEANS_EPOCHS', 'LYNSE_SEARCH_CACHE_SIZE', 'LYNSE_DATALOADER_BUFFER_SIZE']\n\n        data = {\"database_name\": self.database_name}\n        for key in env:\n            if key in env_list:\n                raise_if(TypeError, not isinstance(env[key], str), f'The value of {key} must be a string.')\n                data[key] = env[key]\n\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise_error_response(response)\n\n    def get_environment(self):\n        \"\"\"\n        Get the environment variables.\n\n        Returns:\n            dict: The response from the server.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        uri = f'{self.uri}/get_environment'\n        data = {\"database_name\": self.database_name}\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise_error_response(response)\n\n    def update_collection_description(self, collection: str, description: str):\n        \"\"\"\n        Update the description of a collection.\n\n        Parameters:\n            collection (str): The name of the collection.\n            description (str): The description of the collection.\n\n        Returns:\n            dict: The response from the server.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        uri = f'{self.uri}/update_collection_description'\n        data = {\"database_name\": self.database_name, \"collection_name\": collection, \"description\": description}\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise_error_response(response)\n\n    def show_collections_details(self):\n        \"\"\"\n        Show all collections in the database with details.\n\n        Returns:\n            pandas.DataFrame: The details of the collections.\n\n        Raises:\n            ExecutionError: If the server returns an error.\n        \"\"\"\n        uri = f'{self.uri}/show_collections_details'\n        data = {\"database_name\": self.database_name}\n        response = self._session.post(uri, json=data)\n\n        if response.status_code == 200:\n            rj = response.json()['params']['collections']\n            try:\n                import pandas as pd\n                rj = pd.DataFrame(rj)\n            except ImportError:\n                ...\n\n            return rj\n        else:\n            raise_error_response(response)\n\n    def __repr__(self):\n        if self.database_exists()['params']['exists']:\n            return f\"RemoteDatabaseInstance(name={self.database_name}, exists=True)\"\n        else:\n            return f\"RemoteDatabaseInstance(name={self.database_name}, exists=False)\"\n\n    def __str__(self):\n        return self.__repr__()\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.HTTPClient.__init__","title":"<code>__init__(uri, database_name)</code>","text":"<p>Initialize the client.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The URI of the server, must start with \"http://\" or \"https://\".</p> required <code>database_name</code> <code>str</code> <p>The name of the database.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the URI is not a string.</p> <code>ValueError</code> <p>If the URI does not start with \"http://\" or \"https://\".</p> <code>ConnectionError</code> <p>If the server cannot be connected to.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def __init__(self, uri, database_name):\n    \"\"\"\n    Initialize the client.\n\n    Parameters:\n        uri (str): The URI of the server, must start with \"http://\" or \"https://\".\n        database_name (str): The name of the database.\n\n    Raises:\n        TypeError: If the URI is not a string.\n        ValueError: If the URI does not start with \"http://\" or \"https://\".\n        ConnectionError: If the server cannot be connected to.\n    \"\"\"\n\n    raise_if(TypeError, not isinstance(uri, str), 'The URI must be a string.')\n    raise_if(ValueError, not uri.startswith('http://') or uri.startswith('https://'),\n             'The URI must start with \"http://\" or \"https://\".')\n\n    self._session = httpx.Client()\n\n    if uri.endswith('/'):\n        self.uri = uri[:-1]\n    else:\n        self.uri = uri\n\n    self.database_name = database_name\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.HTTPClient.database_exists","title":"<code>database_exists()</code>","text":"<p>Check if the database exists.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the server.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def database_exists(self):\n    \"\"\"\n    Check if the database exists.\n\n    Returns:\n        dict: The response from the server.\n\n    Raises:\n        ExecutionError: If the server returns an error.\n    \"\"\"\n    uri = f'{self.uri}/database_exists'\n    data = {\"database_name\": self.database_name}\n    response = self._session.post(uri, json=data)\n\n    if response.status_code == 200:\n        return response.json()\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.HTTPClient.drop_collection","title":"<code>drop_collection(collection)</code>","text":"<p>Drop a collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str</code> <p>The name of the collection.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the server.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def drop_collection(self, collection: str):\n    \"\"\"\n    Drop a collection.\n\n    Parameters:\n        collection (str): The name of the collection.\n\n    Returns:\n        dict: The response from the server.\n\n    Raises:\n        ExecutionError: If the server returns an error.\n    \"\"\"\n    try:\n        _ = self.get_collection(collection)\n    except ExecutionError:\n        pass\n\n    uri = f'{self.uri}/drop_collection'\n    data = {\"database_name\": self.database_name, \"collection_name\": collection}\n    return self._session.post(uri, json=data).json()\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.HTTPClient.drop_database","title":"<code>drop_database()</code>","text":"<p>Drop the database.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the server.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def drop_database(self):\n    \"\"\"\n    Drop the database.\n\n    Returns:\n        dict: The response from the server.\n\n    Raises:\n        ExecutionError: If the server returns an error.\n    \"\"\"\n    if not self.database_exists()['params']['exists']:\n        return {'status': 'success', 'message': 'The database does not exist.'}\n\n    uri = f'{self.uri}/drop_database'\n    data = {\"database_name\": self.database_name}\n    response = self._session.post(uri, json=data)\n\n    if response.status_code == 200:\n        return response.json()\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.HTTPClient.get_collection","title":"<code>get_collection(collection, cache_chunks=20, warm_up=True)</code>","text":"<p>Get a collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str</code> <p>The name of the collection.</p> required <code>cache_chunks</code> <code>int</code> <p>The number of chunks to cache. Default is 20.</p> <code>20</code> <code>warm_up</code> <code>bool</code> <p>Whether to warm up. Default is True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Collection</code> <p>The collection object.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def get_collection(self, collection: str, cache_chunks=20, warm_up=True):\n    \"\"\"\n    Get a collection.\n\n    Parameters:\n        collection (str): The name of the collection.\n        cache_chunks (int): The number of chunks to cache. Default is 20.\n        warm_up (bool): Whether to warm up. Default is True.\n\n    Returns:\n        Collection: The collection object.\n\n    Raises:\n        ExecutionError: If the server returns an error.\n    \"\"\"\n    uri = f'{self.uri}/is_collection_exists'\n    data = {\"database_name\": self.database_name, \"collection_name\": collection}\n    response = self._session.post(uri, json=data)\n\n    if response.status_code == 200 and response.json()['params']['exists']:\n        uri = f'{self.uri}/get_collection_config'\n        data = {\"database_name\": self.database_name, \"collection_name\": collection}\n        response = self._session.post(uri, json=data)\n\n        params = response.json()['params']['config']\n        params.update({'cache_chunks': cache_chunks, 'warm_up': warm_up})\n\n        return Collection(uri=self.uri, database_name=self.database_name, collection_name=collection,\n                          **params)\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.HTTPClient.get_environment","title":"<code>get_environment()</code>","text":"<p>Get the environment variables.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the server.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def get_environment(self):\n    \"\"\"\n    Get the environment variables.\n\n    Returns:\n        dict: The response from the server.\n\n    Raises:\n        ExecutionError: If the server returns an error.\n    \"\"\"\n    uri = f'{self.uri}/get_environment'\n    data = {\"database_name\": self.database_name}\n    response = self._session.post(uri, json=data)\n\n    if response.status_code == 200:\n        return response.json()\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.HTTPClient.require_collection","title":"<code>require_collection(collection, dim=None, chunk_size=100000, dtypes='float32', use_cache=True, n_threads=10, warm_up=False, drop_if_exists=False, description=None, cache_chunks=20)</code>","text":"<p>Create a collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str</code> <p>The name of the collection.</p> required <code>dim</code> <code>int</code> <p>The dimension of the vectors. Default is None. When creating a new collection, the dimension of the vectors must be specified. When loading an existing collection, the dimension of the vectors is automatically loaded.</p> <code>None</code> <code>chunk_size</code> <code>int</code> <p>The chunk size. Default is 100,000.</p> <code>100000</code> <code>dtypes</code> <code>str</code> <p>The data types. Default is 'float32'.</p> <code>'float32'</code> <code>use_cache</code> <code>bool</code> <p>Whether to use cache for search. Default is True.</p> <code>True</code> <code>n_threads</code> <code>int</code> <p>The number of threads. Default is 10.</p> <code>10</code> <code>warm_up</code> <code>bool</code> <p>Whether to warm up. Default is False.</p> <code>False</code> <code>drop_if_exists</code> <code>bool</code> <p>Whether to drop the collection if it exists. Default is False.</p> <code>False</code> <code>description</code> <code>str</code> <p>A description of the collection. Default is None. The description is limited to 500 characters.</p> <code>None</code> <code>cache_chunks</code> <code>int</code> <p>The number of chunks to cache in memory. Default is 20.</p> <code>20</code> <p>Returns:</p> Name Type Description <code>Collection</code> <p>The collection object.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If the server cannot be connected to.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def require_collection(\n        self,\n        collection: str,\n        dim: int = None,\n        chunk_size: int = 100_000,\n        dtypes: str = 'float32',\n        use_cache: bool = True,\n        n_threads: Union[int, None] = 10,\n        warm_up: bool = False,\n        drop_if_exists: bool = False,\n        description: str = None,\n        cache_chunks: int = 20\n):\n    \"\"\"\n    Create a collection.\n\n    Parameters:\n        collection (str): The name of the collection.\n        dim (int): The dimension of the vectors. Default is None.\n            When creating a new collection, the dimension of the vectors must be specified.\n            When loading an existing collection, the dimension of the vectors is automatically loaded.\n        chunk_size (int): The chunk size. Default is 100,000.\n        dtypes (str): The data types. Default is 'float32'.\n        use_cache (bool): Whether to use cache for search. Default is True.\n        n_threads (int): The number of threads. Default is 10.\n        warm_up (bool): Whether to warm up. Default is False.\n        drop_if_exists (bool): Whether to drop the collection if it exists. Default is False.\n        description (str): A description of the collection. Default is None.\n            The description is limited to 500 characters.\n        cache_chunks (int): The number of chunks to cache in memory. Default is 20.\n\n    Returns:\n        Collection: The collection object.\n\n    Raises:\n        ConnectionError: If the server cannot be connected to.\n    \"\"\"\n    uri = f'{self.uri}/required_collection'\n\n    data = {\n        \"database_name\": self.database_name,\n        \"collection_name\": collection,\n        \"dim\": dim,\n        \"chunk_size\": chunk_size,\n        \"dtypes\": dtypes,\n        \"use_cache\": use_cache,\n        \"n_threads\": n_threads,\n        \"warm_up\": warm_up,\n        \"drop_if_exists\": drop_if_exists,\n        \"description\": description,\n        \"cache_chunks\": cache_chunks\n    }\n\n    try:\n        response = self._session.post(uri, json=data)\n        if response.status_code == 200:\n            del data['collection_name']\n            del data['database_name']\n            collection = Collection(uri=self.uri, database_name=self.database_name,\n                                    collection_name=collection, **data)\n            return collection\n        else:\n            raise_error_response(response)\n    except httpx.RequestError:\n        raise ConnectionError(f'Failed to connect to the server at {uri}.')\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.HTTPClient.set_environment","title":"<code>set_environment(env)</code>","text":"<p>Set the environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>env</code> <code>dict</code> <p>The environment variables. It can be specified on the same time or separately. - LYNSE_LOG_LEVEL: The log level. - LYNSE_LOG_PATH: The log path. - LYNSE_TRUNCATE_LOG: Whether to truncate the log. - LYNSE_LOG_WITH_TIME: Whether to log with time. - LYNSE_KMEANS_EPOCHS: The number of epochs for KMeans. - LYNSE_SEARCH_CACHE_SIZE: The search cache size. - LYNSE_DATALOADER_BUFFER_SIZE: The dataloader buffer size.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the server.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the value of an environment variable is not a string.</p> <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def set_environment(self, env: dict):\n    \"\"\"\n    Set the environment variables.\n\n    Parameters:\n        env (dict): The environment variables. It can be specified on the same time or separately.\n            - LYNSE_LOG_LEVEL: The log level.\n            - LYNSE_LOG_PATH: The log path.\n            - LYNSE_TRUNCATE_LOG: Whether to truncate the log.\n            - LYNSE_LOG_WITH_TIME: Whether to log with time.\n            - LYNSE_KMEANS_EPOCHS: The number of epochs for KMeans.\n            - LYNSE_SEARCH_CACHE_SIZE: The search cache size.\n            - LYNSE_DATALOADER_BUFFER_SIZE: The dataloader buffer size.\n\n    Returns:\n        dict: The response from the server.\n\n    Raises:\n        TypeError: If the value of an environment variable is not a string.\n        ExecutionError: If the server returns an error.\n    \"\"\"\n    uri = f'{self.uri}/set_environment'\n\n    env_list = ['LYNSE_LOG_LEVEL', 'LYNSE_LOG_PATH', 'LYNSE_TRUNCATE_LOG', 'LYNSE_LOG_WITH_TIME',\n                'LYNSE_KMEANS_EPOCHS', 'LYNSE_SEARCH_CACHE_SIZE', 'LYNSE_DATALOADER_BUFFER_SIZE']\n\n    data = {\"database_name\": self.database_name}\n    for key in env:\n        if key in env_list:\n            raise_if(TypeError, not isinstance(env[key], str), f'The value of {key} must be a string.')\n            data[key] = env[key]\n\n    response = self._session.post(uri, json=data)\n\n    if response.status_code == 200:\n        return response.json()\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.HTTPClient.show_collections","title":"<code>show_collections()</code>","text":"<p>Show all collections in the database.</p> <p>Returns:</p> Name Type Description <code>List</code> <p>The list of collections.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def show_collections(self):\n    \"\"\"\n    Show all collections in the database.\n\n    Returns:\n        List: The list of collections.\n\n    Raises:\n        ExecutionError: If the server returns an error.\n    \"\"\"\n    uri = f'{self.uri}/show_collections'\n    data = {\"database_name\": self.database_name}\n    response = self._session.post(uri, json=data)\n\n    if response.status_code == 200:\n        return response.json()['params']['collections']\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.HTTPClient.show_collections_details","title":"<code>show_collections_details()</code>","text":"<p>Show all collections in the database with details.</p> <p>Returns:</p> Type Description <p>pandas.DataFrame: The details of the collections.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def show_collections_details(self):\n    \"\"\"\n    Show all collections in the database with details.\n\n    Returns:\n        pandas.DataFrame: The details of the collections.\n\n    Raises:\n        ExecutionError: If the server returns an error.\n    \"\"\"\n    uri = f'{self.uri}/show_collections_details'\n    data = {\"database_name\": self.database_name}\n    response = self._session.post(uri, json=data)\n\n    if response.status_code == 200:\n        rj = response.json()['params']['collections']\n        try:\n            import pandas as pd\n            rj = pd.DataFrame(rj)\n        except ImportError:\n            ...\n\n        return rj\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.HTTPClient.update_collection_description","title":"<code>update_collection_description(collection, description)</code>","text":"<p>Update the description of a collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str</code> <p>The name of the collection.</p> required <code>description</code> <code>str</code> <p>The description of the collection.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the server.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def update_collection_description(self, collection: str, description: str):\n    \"\"\"\n    Update the description of a collection.\n\n    Parameters:\n        collection (str): The name of the collection.\n        description (str): The description of the collection.\n\n    Returns:\n        dict: The response from the server.\n\n    Raises:\n        ExecutionError: If the server returns an error.\n    \"\"\"\n    uri = f'{self.uri}/update_collection_description'\n    data = {\"database_name\": self.database_name, \"collection_name\": collection, \"description\": description}\n    response = self._session.post(uri, json=data)\n\n    if response.status_code == 200:\n        return response.json()\n    else:\n        raise_error_response(response)\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.pack_data","title":"<code>pack_data(data)</code>","text":"<p>Pack the data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>The data to pack.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <p>The packed data.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def pack_data(data):\n    \"\"\"\n    Pack the data.\n\n    Parameters:\n        data: The data to pack.\n\n    Returns:\n        bytes: The packed data.\n    \"\"\"\n    packed_data = msgpack.packb(data, use_bin_type=True)\n    return packed_data\n</code></pre>"},{"location":"http_api/client_api/#lynse.api.http_api.client_api.raise_error_response","title":"<code>raise_error_response(response)</code>","text":"<p>Raise an error response.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <p>The response from the server.</p> required <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If the server returns an error.</p> Source code in <code>lynse/api/http_api/client_api.py</code> <pre><code>def raise_error_response(response):\n    \"\"\"\n    Raise an error response.\n\n    Parameters:\n        response: The response from the server.\n\n    Raises:\n        ExecutionError: If the server returns an error.\n    \"\"\"\n    try:\n        rj = response.json()\n        raise ExecutionError(rj)\n    except Exception as e:\n        raise ExecutionError(response.text)\n</code></pre>"},{"location":"http_api/serve_api/app/","title":"App","text":""},{"location":"http_api/serve_api/app/#lynse.api.http_api.http_api.app.launch_in_jupyter","title":"<code>launch_in_jupyter(host='127.0.0.1', port=7637, threads=10)</code>","text":"<p>Launch the HTTP API server in Python environment.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The host to bind to. Default is '127.0.0.1'</p> <code>'127.0.0.1'</code> <code>port</code> <code>int</code> <p>The port to bind to. Default is 7637.</p> <code>7637</code> <code>threads</code> <code>int</code> <p>Number of threads per worker. Default is 10.</p> <code>10</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>lynse/api/http_api/http_api/app.py</code> <pre><code>def launch_in_jupyter(host: str = '127.0.0.1', port: int = 7637, threads: int = 10):\n    \"\"\"\n    Launch the HTTP API server in Python environment.\n\n    Parameters:\n        host (str): The host to bind to. Default is '127.0.0.1'\n        port (int): The port to bind to. Default is 7637.\n        threads (int): Number of threads per worker. Default is 10.\n\n    Returns:\n        None\n    \"\"\"\n    import threading\n    if host == '0.0.0.0':\n        local_ip = get_local_ip()\n        print(f\"Server running at:\")\n        print(f\"  - Localhost: http://localhost:{port}\")\n        print(f\"  - Local IP: http://{local_ip}:{port}\", end=\"\\n\\n\")\n    else:\n        print(f\"Server running at http://{host}:{port}\", end=\"\\n\\n\")\n\n    # set the thread as daemon thread\n    server_thread = threading.Thread(target=serve, args=(app,), kwargs={'host': host, 'port': port, 'threads': threads})\n    server_thread.daemon = True\n    server_thread.start()\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/","title":"Collection Serve API","text":""},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.build_field_index","title":"<code>build_field_index()</code>","text":"<p>Build the index of a field.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/build_field_index', methods=['POST'])\ndef build_field_index():\n    \"\"\"Build the index of a field.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        collection = my_vec_db.get_collection(data['collection_name'])\n\n        schema = IndexSchema().load_from_dict(data['schema'])\n\n        collection.build_field_index(schema=schema,\n                                     rebuild_if_exists=data['rebuild_if_exists'])\n\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name']\n        }}, sort_keys=False), mimetype='application/json')\n    except KeyError as e:\n        return jsonify({'error': f'Missing required parameter {e}'}), 400\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.build_index","title":"<code>build_index()</code>","text":"<p>Build the index of a collection.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/build_index', methods=['POST'])\ndef build_index():\n    \"\"\"Build the index of a collection.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        collection = my_vec_db.get_collection(data['collection_name'])\n        collection.build_index(index_mode=data.get('index_mode', 'IVF-FLAT'))\n\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name'], 'index_mode': data.get('index_mode', 'IVF-FLAT')\n        }}, sort_keys=False), mimetype='application/json')\n    except KeyError as e:\n        return jsonify({'error': f'Missing required parameter {e}'}), 400\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.collection_shape","title":"<code>collection_shape()</code>","text":"<p>Get the shape of a collection.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/collection_shape', methods=['POST'])\ndef collection_shape():\n    \"\"\"Get the shape of a collection.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        collection = my_vec_db.get_collection(data['collection_name'])\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name'], 'shape': collection.shape\n        }}, sort_keys=False), mimetype='application/json')\n    except KeyError as e:\n        return jsonify({'error': f'Missing required parameter {e}'}), 400\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.get_collection_config","title":"<code>get_collection_config()</code>","text":"<p>Get the configuration of a collection.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/get_collection_config', methods=['POST'])\ndef get_collection_config():\n    \"\"\"Get the configuration of a collection.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    try:\n        config_json_path = root_path / data['database_name'] / 'collections.json'\n        with open(config_json_path, 'r') as file:\n            collections = json.load(file)\n            collection_config = collections[data['collection_name']]\n\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name'], 'config': collection_config\n        }}, sort_keys=False), mimetype='application/json')\n    except KeyError as e:\n        return jsonify({'error': f'Missing required parameter {e}'}), 400\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.get_collection_path","title":"<code>get_collection_path()</code>","text":"<p>Get the path of a database.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/get_collection_path', methods=['POST'])\ndef get_collection_path():\n    \"\"\"Get the path of a database.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        collection = my_vec_db.get_collection(data['collection_name'])\n\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name'],\n            'collection_path': collection._database_path}}, sort_keys=False), mimetype='application/json')\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.get_collection_status_report","title":"<code>get_collection_status_report()</code>","text":"<p>Get the status report of a collection.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/get_collection_status_report', methods=['POST'])\ndef get_collection_status_report():\n    \"\"\"Get the status report of a collection.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        collection = my_vec_db.get_collection(data['collection_name'])\n\n        db_report = {'DATABASE STATUS REPORT': {\n            'Database shape': (\n                0, collection._matrix_serializer.dim) if collection._matrix_serializer.IS_DELETED else collection.shape,\n            'Database last_commit_time': collection._matrix_serializer.last_commit_time,\n            'Database commit status': collection._matrix_serializer.COMMIT_FLAG,\n            'Database use_cache': collection._use_cache,\n            'Database status': 'DELETED' if collection._matrix_serializer.IS_DELETED else 'ACTIVE'\n        }}\n\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name'], 'status_report': db_report\n        }}, sort_keys=False), mimetype='application/json')\n    except KeyError as e:\n        return jsonify({'error': f'Missing required parameter {e}'}), 400\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.get_commit_msg","title":"<code>get_commit_msg()</code>","text":"<p>Get the commit message of a collection.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/get_commit_msg', methods=['POST'])\ndef get_commit_msg():\n    \"\"\"Get the commit message of a collection.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    try:\n        if (root_path / data['database_name'] / 'commit_msg.json').exists():\n            with open(root_path / data['database_name'] / 'commit_msg.json', 'r') as file:\n                commit_msg = json.load(file)\n                commit_msg = commit_msg.get(data['collection_name'], None)\n        else:\n            commit_msg = 'No commit message found for this collection'\n\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name'], 'commit_msg': commit_msg\n        }}, sort_keys=False), mimetype='application/json')\n    except KeyError as e:\n        return jsonify({'error': f'Missing required parameter {e}'}), 400\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.head","title":"<code>head()</code>","text":"<p>Get the first n items of a collection.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/head', methods=['POST'])\ndef head():\n    \"\"\"Get the first n items of a collection.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    if 'n' not in data:\n        data['n'] = 5\n\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        collection = my_vec_db.get_collection(data['collection_name'])\n        head = collection.head(n=data['n'])\n        head = (head[0].tolist(), head[1].tolist(), head[2])\n\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name'], 'head': head\n        }}, sort_keys=False), mimetype='application/json')\n    except KeyError as e:\n        return jsonify({'error': f'Missing required parameter {e}'}), 400\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.index_mode","title":"<code>index_mode()</code>","text":"<p>Get the index mode of a collection.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/index_mode', methods=['POST'])\ndef index_mode():\n    \"\"\"Get the index mode of a collection.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        collection = my_vec_db.get_collection(data['collection_name'])\n\n        index_mode = collection.index_mode\n\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name'],\n            'index_mode': index_mode\n        }}, sort_keys=False), mimetype='application/json')\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.is_collection_exists","title":"<code>is_collection_exists()</code>","text":"<p>Check if a collection exists.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/is_collection_exists', methods=['POST'])\ndef is_collection_exists():\n    \"\"\"Check if a collection exists.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name'],\n            'exists': data['collection_name'] in my_vec_db.show_collections()\n        }}, sort_keys=False), mimetype='application/json')\n    except KeyError as e:\n        return jsonify({'error': f'Missing required parameter {e}'}), 400\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.is_id_exists","title":"<code>is_id_exists()</code>","text":"<p>Check if an ID exists in the database.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/is_id_exists', methods=['POST'])\ndef is_id_exists():\n    \"\"\"Check if an ID exists in the database.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        collection = my_vec_db.get_collection(data['collection_name'])\n\n        is_id_exists = collection.is_id_exists(data['id'])\n\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name'],\n            'id': data['id'],\n            'is_id_exists': is_id_exists\n        }}, sort_keys=False), mimetype='application/json')\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.list_field_index","title":"<code>list_field_index()</code>","text":"<p>List all field indexes of a collection.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/list_field_index', methods=['POST'])\ndef list_field_index():\n    \"\"\"List all field indexes of a collection.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        collection = my_vec_db.get_collection(data['collection_name'])\n\n        field_indices = collection.list_field_index()\n\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name'],\n            'field_indices': field_indices}}, sort_keys=False), mimetype='application/json')\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.list_fields","title":"<code>list_fields()</code>","text":"<p>List all fields of a collection.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/list_fields', methods=['POST'])\ndef list_fields():\n    \"\"\"List all fields of a collection.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        collection = my_vec_db.get_collection(data['collection_name'])\n        fields = collection.list_fields()\n\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name'],\n            'fields': fields\n        }}, sort_keys=False), mimetype='application/json')\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.max_id","title":"<code>max_id()</code>","text":"<p>Get the maximum ID in the collection.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/max_id', methods=['POST'])\ndef max_id():\n    \"\"\"Get the maximum ID in the collection.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        collection = my_vec_db.get_collection(data['collection_name'])\n\n        max_id = int(collection.max_id)\n\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name'],\n            'max_id': max_id\n        }}, sort_keys=False), mimetype='application/json')\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.query","title":"<code>query()</code>","text":"<p>Query the database.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/query', methods=['POST'])\ndef query():\n    \"\"\"Query the database.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        collection = my_vec_db.get_collection(data['collection_name'])\n\n        result = collection.query(data['query_filter'], data['filter_ids'], data['return_ids_only'])\n\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name'],\n            'result': result}}, sort_keys=False), mimetype='application/json')\n    except KeyError as e:\n        return jsonify({'error': f'Missing required parameter {e}'}), 400\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.query_vectors","title":"<code>query_vectors()</code>","text":"<p>Query the database.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/query_vectors', methods=['POST'])\ndef query_vectors():\n    \"\"\"Query the database.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        collection = my_vec_db.get_collection(data['collection_name'])\n\n        result = collection.query_vectors(data['query_filter'], data['filter_ids'])\n        result = (result[0].tolist(), result[1].tolist(), result[2])\n\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name'],\n            'result': result}}, sort_keys=False), mimetype='application/json')\n    except KeyError as e:\n        return jsonify({'error': f'Missing required parameter {e}'}), 400\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.read_by_only_id","title":"<code>read_by_only_id()</code>","text":"<p>Read the item by only id.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/read_by_only_id', methods=['POST'])\ndef read_by_only_id():\n    \"\"\"Read the item by only id.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        collection = my_vec_db.get_collection(data['collection_name'])\n        vector, id, field = collection.read_by_only_id(data['id'])\n        vector = vector.tolist()\n        id = id.tolist()\n\n        item = (vector, id, field)\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name'], 'item': item\n        }}, sort_keys=False), mimetype='application/json')\n    except KeyError as e:\n        return jsonify({'error': f'Missing required parameter {e}'}), 400\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.remove_all_field_indices","title":"<code>remove_all_field_indices()</code>","text":"<p>Remove all field indices of a collection.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/remove_all_field_indices', methods=['POST'])\ndef remove_all_field_indices():\n    \"\"\"Remove all field indices of a collection.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        collection = my_vec_db.get_collection(data['collection_name'])\n\n        collection.remove_all_field_indices()\n\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name']\n        }}, sort_keys=False), mimetype='application/json')\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.remove_field_index","title":"<code>remove_field_index()</code>","text":"<p>Remove the index of a field.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/remove_field_index', methods=['POST'])\ndef remove_field_index():\n    \"\"\"Remove the index of a field.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        collection = my_vec_db.get_collection(data['collection_name'])\n\n        collection.remove_field_index(data['field_name'])\n\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name'],\n            'field_name': data['field_name']\n        }}, sort_keys=False), mimetype='application/json')\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.remove_index","title":"<code>remove_index()</code>","text":"<p>Remove the index of a collection.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/remove_index', methods=['POST'])\ndef remove_index():\n    \"\"\"Remove the index of a collection.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        collection = my_vec_db.get_collection(data['collection_name'])\n        collection.remove_index()\n\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name']\n        }}, sort_keys=False), mimetype='application/json')\n    except KeyError as e:\n        return jsonify({'error': f'Missing required parameter {e}'}), 400\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.search","title":"<code>search()</code>","text":"<p>Search the database for the vectors most similar to the given vector.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/search', methods=['POST'])\ndef search():\n    \"\"\"Search the database for the vectors most similar to the given vector.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n    from ....core_components.fields_cache.filter import Filter\n\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    if 'k' not in data:\n        data['k'] = 10\n\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        collection = my_vec_db.get_collection(data['collection_name'])\n\n        if data['search_filter'] is None:\n            search_filter = None\n        else:\n            search_filter = Filter().load_dict(data['search_filter'])\n\n        indexer = getattr(collection, '_indexer', None)\n        if indexer is not None:\n            index_mode_judge = 'Binary' not in indexer.index_mode\n        else:\n            index_mode_judge = False\n\n        ids, scores, field = collection.search(\n            vector=data['vector'], k=data['k'],\n            search_filter=search_filter,\n            return_fields=data.get('return_fields', False),\n            rescore=data.get('rescore', False),\n            rescore_multiplier=(data.get('rescore_multiplier', 2)\n                                if index_mode_judge else data.get('rescore_multiplier', 10))\n        )\n\n        if ids is not None:\n            ids = ids.tolist()\n            scores = scores.tolist()\n\n        return Response(json.dumps(\n            {\n                'status': 'success', 'params': {\n                'database_name': data['database_name'],\n                'collection_name': data['collection_name'], 'items': {\n                    'k': data['k'], 'ids': ids, 'scores': scores,\n                    'fields': field,\n                }\n            }\n            }, sort_keys=False),\n            mimetype='application/json')\n    except KeyError as e:\n        return jsonify({'error': f'Missing required parameter {e}'}), 400\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.show_collections","title":"<code>show_collections()</code>","text":"<p>Show all collections in the database.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/show_collections', methods=['POST'])\ndef show_collections():\n    \"\"\"Show all collections in the database.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    if 'database_name' not in data:\n        return jsonify({'error': 'Missing required parameter: database_name'}), 400\n\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        collections = my_vec_db.show_collections()\n\n        return Response(json.dumps({\n            'status': 'success', 'params': {\n                'database_name': data['database_name'],\n                'collections': collections\n            }\n        }, sort_keys=False), mimetype='application/json')\n\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.show_collections_details","title":"<code>show_collections_details()</code>","text":"<p>Show all collections in the database with details.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/show_collections_details', methods=['POST'])\ndef show_collections_details():\n    \"\"\"Show all collections in the database with details.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        collections_details = my_vec_db.show_collections_details()\n        return Response(json.dumps({\n            'status': 'success', 'params': {\n                'database_name': data['database_name'],\n                'collections': collections_details.to_dict()\n            }\n        },\n            sort_keys=False), mimetype='application/json')\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.tail","title":"<code>tail()</code>","text":"<p>Get the last n items of a collection.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/tail', methods=['POST'])\ndef tail():\n    \"\"\"Get the last n items of a collection.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    if 'n' not in data:\n        data['n'] = 5\n\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        collection = my_vec_db.get_collection(data['collection_name'])\n        tail = collection.tail(n=data['n'])\n        tail = (tail[0].tolist(), tail[1].tolist(), tail[2])\n\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name'], 'tail': tail\n        }}, sort_keys=False), mimetype='application/json')\n    except KeyError as e:\n        return jsonify({'error': f'Missing required parameter {e}'}), 400\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.update_collection_description","title":"<code>update_collection_description()</code>","text":"<p>Update the description of a collection.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/update_collection_description', methods=['POST'])\ndef update_collection_description():\n    \"\"\"Update the description of a collection.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        my_vec_db.update_collection_description(data['collection_name'], data['description'])\n\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name'], 'description': data['description']\n        }}, sort_keys=False), mimetype='application/json')\n    except KeyError as e:\n        return jsonify({'error': f'Missing required parameter {e}'}), 400\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.update_commit_msg","title":"<code>update_commit_msg()</code>","text":"<p>Save the commit message of a collection.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/update_commit_msg', methods=['POST'])\ndef update_commit_msg():\n    \"\"\"Save the commit message of a collection.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    try:\n        if (root_path / data['database_name'] / 'commit_msg.json').exists():\n            with open(root_path / data['database_name'] / 'commit_msg.json', 'r') as file:\n                commit_msg = json.load(file)\n                commit_msg[data['collection_name']] = data\n        else:\n            commit_msg = {data['collection_name']: data}\n\n        with open(root_path / data['database_name'] / 'commit_msg.json', 'w') as file:\n            json.dump(commit_msg, file)\n\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name']\n        }}, sort_keys=False), mimetype='application/json')\n    except KeyError as e:\n        return jsonify({'error': f'Missing required parameter {e}'}), 400\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/collection_ops/#lynse.api.http_api.http_api.collection_ops.update_description","title":"<code>update_description()</code>","text":"<p>Update the description of the database.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/collection_ops.py</code> <pre><code>@collection_ops.route('/update_description', methods=['POST'])\ndef update_description():\n    \"\"\"Update the description of the database.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    try:\n        my_vec_db = LocalClient(root_path=root_path / data['database_name'])\n        collection = my_vec_db.get_collection(data['collection_name'])\n        collection.update_description(data['description'])\n\n        return Response(json.dumps({'status': 'success', 'params': {\n            'database_name': data['database_name'],\n            'collection_name': data['collection_name'],\n            'description': data['description']\n        }}, sort_keys=False), mimetype='application/json')\n    except KeyError as e:\n        return jsonify({'error': f'Missing required parameter {e}'}), 400\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/database_ops/","title":"Database Serve API","text":""},{"location":"http_api/serve_api/database_ops/#lynse.api.http_api.http_api.database_ops.create_database","title":"<code>create_database()</code>","text":"<p>Create a database.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/database_ops.py</code> <pre><code>@database_ops.route('/create_database', methods=['POST'])\ndef create_database():\n    \"\"\"Create a database.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.database_manager import DatabaseManager\n    from ....api.native_api.high_level import LocalClient\n\n    data = request.json\n    try:\n        data_manager = DatabaseManager(config.LYNSE_DEFAULT_ROOT_PATH)\n        data_manager.register(data['database_name'])\n\n        if data['drop_if_exists']:\n            LocalClient(root_path=root_path / data['database_name']).drop_database()\n\n        LocalClient(root_path=root_path / data['database_name'])\n        return Response(json.dumps({'status': 'success', 'params': {'database_name': data['database_name']}},\n                                   sort_keys=False), mimetype='application/json')\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/database_ops/#lynse.api.http_api.http_api.database_ops.database_exists","title":"<code>database_exists()</code>","text":"<p>Check if the database exists.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/database_ops.py</code> <pre><code>@database_ops.route('/database_exists', methods=['POST'])\ndef database_exists():\n    \"\"\"Check if the database exists.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    data = request.json\n    try:\n        exists = (root_path / data['database_name']).exists()\n        return Response(json.dumps({\n            'status': 'success', 'params': {\n                'exists': True if exists else False\n            }\n        },\n            sort_keys=False), mimetype='application/json')\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/database_ops/#lynse.api.http_api.http_api.database_ops.delete_database","title":"<code>delete_database()</code>","text":"<p>Delete a database.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/database_ops.py</code> <pre><code>@database_ops.route('/delete_database', methods=['POST'])\ndef delete_database():\n    \"\"\"Delete a database.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.database_manager import DatabaseManager\n\n    data = request.json\n    try:\n        data_manager = DatabaseManager(config.LYNSE_DEFAULT_ROOT_PATH)\n        data_manager.delete(data['database_name'])\n        return Response(json.dumps({'status': 'success', 'params': {'database_name': data['database_name']}},\n                                   sort_keys=False), mimetype='application/json')\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/database_ops/#lynse.api.http_api.http_api.database_ops.get_environment","title":"<code>get_environment()</code>","text":"<p>Get the environment variables.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/database_ops.py</code> <pre><code>@database_ops.route('/get_environment', methods=['GET'])\ndef get_environment():\n    \"\"\"Get the environment variables.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    env_list = ['LYNSE_LOG_LEVEL', 'LYNSE_LOG_PATH', 'LYNSE_TRUNCATE_LOG', 'LYNSE_LOG_WITH_TIME',\n                'LYNSE_KMEANS_EPOCHS', 'LYNSE_SEARCH_CACHE_SIZE']\n\n    params = {key: eval(\"global_config.key\") for key in env_list}\n    try:\n        return Response(json.dumps({'status': 'success', 'params': params}, sort_keys=False),\n                        mimetype='application/json')\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/database_ops/#lynse.api.http_api.http_api.database_ops.list_databases","title":"<code>list_databases()</code>","text":"<p>List all databases.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/database_ops.py</code> <pre><code>@database_ops.route('/list_databases', methods=['GET'])\ndef list_databases():\n    \"\"\"List all databases.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    from ....api.native_api.database_manager import DatabaseManager\n\n    try:\n        data_manager = DatabaseManager(config.LYNSE_DEFAULT_ROOT_PATH)\n        databases = data_manager.list_database()\n        return Response(json.dumps({'status': 'success', 'params': {'databases': databases}}, sort_keys=False),\n                        mimetype='application/json')\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"http_api/serve_api/database_ops/#lynse.api.http_api.http_api.database_ops.set_environment","title":"<code>set_environment()</code>","text":"<p>Set the environment variables.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The status of the operation.</p> Source code in <code>lynse/api/http_api/http_api/database_ops.py</code> <pre><code>@database_ops.route('/set_environment', methods=['POST'])\ndef set_environment():\n    \"\"\"Set the environment variables.\n\n    Returns:\n        dict: The status of the operation.\n    \"\"\"\n    data = request.json\n    if not data:\n        return jsonify({'error': 'No data provided'}), 400\n\n    try:\n        for key, value in data.items():\n            os.environ[key] = value\n        return Response(json.dumps({'status': 'success', 'params': data}, sort_keys=False), mimetype='application/json')\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n</code></pre>"},{"location":"native_api/high_level/","title":"LocalClient API","text":""},{"location":"native_api/high_level/#lynse.api.native_api.high_level.LocalClient","title":"<code>LocalClient</code>","text":"<p>A singleton class for the local LynseDB client. Using the LocalClient class, users can create and access database instances, as well as operate on the collections within them (Low-Level API). This class is thread-safe only. Using it in multiple processes will result in a race condition.</p> Source code in <code>lynse/api/native_api/high_level.py</code> <pre><code>class LocalClient:\n    \"\"\"\n    A singleton class for the local LynseDB client.\n    Using the LocalClient class, users can create and access database instances,\n    as well as operate on the collections within them (Low-Level API).\n    This class is thread-safe only. Using it in multiple processes will result in a race condition.\n    \"\"\"\n    _instance = None\n    _last_root_path = None\n\n    def __new__(cls, root_path: Union[Path, str]):\n        \"\"\"\n        Create a new instance or return the existing instance of the class.\n\n        Parameters:\n            root_path (Path or str): The root path of the database.\n\n        Returns:\n            LocalClient (LocalClient): The instance of the class.\n        \"\"\"\n        if cls._instance is not None and cls._last_root_path != root_path:\n            cls._instance = None\n            cls._last_root_path = root_path\n\n        if cls._instance is None:\n            cls._instance = super(LocalClient, cls).__new__(cls)\n            cls._instance._init(root_path)\n\n            cls._last_root_path = root_path\n\n        Path(cls._last_root_path).mkdir(parents=True, exist_ok=True)\n\n        if not (Path(cls._last_root_path) / '.fingerprint').exists():\n            # create a database fingerprint\n            with open(Path(cls._last_root_path) / '.fingerprint', 'w') as f:\n                f.write(uuid.uuid4().hex)\n\n        return cls._instance\n\n    def _init(self, root_path: Union[Path, str]):\n        \"\"\"\n        Initialize the vector database.\n        \"\"\"\n        self._root_path = Path(root_path).absolute()\n\n        self._register = _Register(root_path)\n        self._collections = {}\n        self.STATUS = 'INITIALIZED'\n\n    def require_collection(\n            self,\n            collection: str,\n            dim: int = None,\n            chunk_size: int = 100_000,\n            dtypes: str = 'float32',\n            use_cache: bool = True,\n            n_threads: Union[int, None] = 10,\n            warm_up: bool = False,\n            drop_if_exists: bool = False,\n            description: str = None,\n            cache_chunks: int = 20\n    ):\n        \"\"\"Create or load a collection in the database.\n\n        Parameters:\n            collection (str): The name of the collection.\n            dim (int): Dimension of the vectors. Default is None.\n                When creating a new collection, the dimension of the vectors must be specified.\n                When loading an existing collection, the dimension of the vectors is automatically loaded.\n            chunk_size (int): The size of each data chunk. Default is 100_000.\n            dtypes (str): The data type of the vectors. Default is 'float32'.\n                Options are 'float16', 'float32' or 'float64'.\n            use_cache (bool): Whether to use cache for search. Default is True.\n            n_threads (int): The number of threads to use for parallel processing. Default is 10.\n            warm_up (bool): Whether to warm up the database. Default is False.\n            drop_if_exists (bool): Whether to drop the collection if it already exists. Default is False.\n            description (str): A description of the collection. Default is None.\n                The description is limited to 500 characters.\n            cache_chunks (int): The number of chunks to cache. Default is 20.\n\n        Raises:\n            ValueError: If `chunk_size` is less than or equal to 1.\n        \"\"\"\n        from ...api.native_api.low_level import ExclusiveDB\n\n        collection_path = self._root_path / collection\n\n        if description is not None and not isinstance(description, str):\n            raise ValueError('Description must be a string')\n        elif description is not None and len(description) &gt; 500:\n            raise ValueError('Description must be less than 500 characters')\n\n        if collection in self._register:\n            if drop_if_exists:\n                self.drop_collection(collection)\n                logger.info(f\"Collection '{collection}' already exists. Dropped.\")\n            else:\n                collection_details = self._register.get_collections_details()[collection]\n                dim = collection_details['dim']\n                logger.info(f\"Collection '{collection}' already exists. Loaded.\")\n\n        if chunk_size &lt;= 1:\n            raise ValueError('chunk_size must be greater than 1')\n\n        self._collections[collection] = ExclusiveDB(\n            dim=dim, database_path=collection_path.as_posix(), chunk_size=chunk_size, dtypes=dtypes,\n            use_cache=use_cache, n_threads=n_threads,\n            warm_up=warm_up, cache_chunks=cache_chunks\n        )\n\n        self._register.register_collection(\n            collection, dim=dim, database_path=collection_path.as_posix(), chunk_size=chunk_size, dtypes=dtypes,\n            use_cache=use_cache, n_threads=n_threads,\n            warm_up=warm_up, description=description, cache_chunks=cache_chunks\n        )\n\n        self._collections[collection].update_description = partial(self.update_collection_description, collection)\n\n        return self._collections[collection]\n\n    @unavailable_if_deleted\n    def get_collection(self, collection: str, cache_chunks: int = 20, warm_up: bool = True):\n        \"\"\"\n        Get a collection from the database.\n\n        Parameters:\n            collection (str): The name of the collection to get.\n            cache_chunks (int): The number of chunks to cache. Default is 20.\n            warm_up (bool): Whether to warm up the database. Default is True.\n\n        Returns:\n            (ExclusiveDB): The collection.\n        \"\"\"\n        from ...api.native_api.low_level import ExclusiveDB\n\n        if collection not in self._collections:\n            if collection not in self._register:\n                raise ValueError(f\"Collection '{collection}' does not exist.\")\n\n            params = self._register.get_collections_details()[collection]\n            params.update({'cache_chunks': cache_chunks, 'warm_up': warm_up})\n            if 'description' in params:\n                del params['description']\n            self._collections[collection] = ExclusiveDB(**params)\n\n        return self._collections[collection]\n\n    @unavailable_if_deleted\n    def copy_collection(self, deep=False):\n        \"\"\"\n        Copy the collection.\n\n        Parameters:\n            deep (bool): Whether to make a deep copy. Default is False.\n                Which means share the data with the original collection.\n\n        Returns:\n            (ExclusiveDB): The copied collection.\n\n        Raises:\n            NotImplementedError: This method is not implemented yet.\n        \"\"\"\n        raise NotImplementedError(\"This method is not implemented yet.\")\n\n    @unavailable_if_deleted\n    def show_collections(self):\n        \"\"\"\n        Show the collections in the database.\n\n        Returns:\n            List: The list of collections in the database.\n        \"\"\"\n        return self._register.show_collections()\n\n    @unavailable_if_deleted\n    def drop_collection(self, collection: str):\n        \"\"\"\n        Delete a collection from the database.\n\n        Parameters:\n            collection (str): The name of the collection to delete.\n\n        Returns:\n            None\n        \"\"\"\n\n        if collection in self._collections:\n            self._collections[collection].delete()\n            del self._collections[collection]\n            self._register.deregister_collection(collection)\n        else:\n            try:\n                _temp_collection = self.get_collection(collection)\n                self.drop_collection(collection)\n            except ValueError:\n                pass\n\n        if (self._root_path / \"collections.json\").exists():\n            with open(self._root_path / \"collections.json\", \"r\") as f:\n                collections = json.load(f)\n                if collection in collections:\n                    del collections[collection]\n\n            with open(self._root_path / \"collections.json\", \"w\") as f:\n                json.dump(collections, f)\n\n    def drop_database(self):\n        \"\"\"\n        Delete the database.\n\n        Returns:\n            None\n        \"\"\"\n        if self.STATUS == 'DELETED':\n            return\n\n        if self._root_path.exists():\n            shutil.rmtree(self._root_path)\n\n        LocalClient._instance = None\n        self.STATUS = 'DELETED'\n\n    def update_collection_description(self, collection: str, description: Union[None, str, int, float, bool]):\n        \"\"\"\n        Update the description of the collection.\n\n        Parameters:\n            collection (str): The name of the collection.\n            description (None or str or int or float or bool): The description of the collection.\n\n        Returns:\n            None\n        \"\"\"\n        self._register.update_description(collection, description)\n\n    def show_collections_details(self):\n        \"\"\"\n        Show the collections in the database.\n\n        Returns:\n            (Dict or DataFrame): The details of the collections in the database.\n        \"\"\"\n        return self._register.show_collections_details()\n\n    def database_exists(self):\n        \"\"\"\n        Check if the database exists.\n\n        Returns:\n            (Bool): Whether the database exists.\n        \"\"\"\n        return self._root_path.exists()\n\n    @property\n    def root_path(self):\n        \"\"\"\n        Get the root path of the database.\n\n        Returns:\n            (str): The root path of the database.\n        \"\"\"\n        return self._root_path.as_posix()\n\n    def __repr__(self):\n        return (f'{self.__class__.__name__.replace(\"Client\", \"DatabaseInstance\")}(name={self._root_path.name},'\n                f' exists={self.database_exists()})')\n\n    def __str__(self):\n        return self.__repr__()\n</code></pre>"},{"location":"native_api/high_level/#lynse.api.native_api.high_level.LocalClient.root_path","title":"<code>root_path</code>  <code>property</code>","text":"<p>Get the root path of the database.</p> <p>Returns:</p> Type Description <code>str</code> <p>The root path of the database.</p>"},{"location":"native_api/high_level/#lynse.api.native_api.high_level.LocalClient.__new__","title":"<code>__new__(root_path)</code>","text":"<p>Create a new instance or return the existing instance of the class.</p> <p>Parameters:</p> Name Type Description Default <code>root_path</code> <code>Path or str</code> <p>The root path of the database.</p> required <p>Returns:</p> Name Type Description <code>LocalClient</code> <code>LocalClient</code> <p>The instance of the class.</p> Source code in <code>lynse/api/native_api/high_level.py</code> <pre><code>def __new__(cls, root_path: Union[Path, str]):\n    \"\"\"\n    Create a new instance or return the existing instance of the class.\n\n    Parameters:\n        root_path (Path or str): The root path of the database.\n\n    Returns:\n        LocalClient (LocalClient): The instance of the class.\n    \"\"\"\n    if cls._instance is not None and cls._last_root_path != root_path:\n        cls._instance = None\n        cls._last_root_path = root_path\n\n    if cls._instance is None:\n        cls._instance = super(LocalClient, cls).__new__(cls)\n        cls._instance._init(root_path)\n\n        cls._last_root_path = root_path\n\n    Path(cls._last_root_path).mkdir(parents=True, exist_ok=True)\n\n    if not (Path(cls._last_root_path) / '.fingerprint').exists():\n        # create a database fingerprint\n        with open(Path(cls._last_root_path) / '.fingerprint', 'w') as f:\n            f.write(uuid.uuid4().hex)\n\n    return cls._instance\n</code></pre>"},{"location":"native_api/high_level/#lynse.api.native_api.high_level.LocalClient.copy_collection","title":"<code>copy_collection(deep=False)</code>","text":"<p>Copy the collection.</p> <p>Parameters:</p> Name Type Description Default <code>deep</code> <code>bool</code> <p>Whether to make a deep copy. Default is False. Which means share the data with the original collection.</p> <code>False</code> <p>Returns:</p> Type Description <code>ExclusiveDB</code> <p>The copied collection.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method is not implemented yet.</p> Source code in <code>lynse/api/native_api/high_level.py</code> <pre><code>@unavailable_if_deleted\ndef copy_collection(self, deep=False):\n    \"\"\"\n    Copy the collection.\n\n    Parameters:\n        deep (bool): Whether to make a deep copy. Default is False.\n            Which means share the data with the original collection.\n\n    Returns:\n        (ExclusiveDB): The copied collection.\n\n    Raises:\n        NotImplementedError: This method is not implemented yet.\n    \"\"\"\n    raise NotImplementedError(\"This method is not implemented yet.\")\n</code></pre>"},{"location":"native_api/high_level/#lynse.api.native_api.high_level.LocalClient.database_exists","title":"<code>database_exists()</code>","text":"<p>Check if the database exists.</p> <p>Returns:</p> Type Description <code>Bool</code> <p>Whether the database exists.</p> Source code in <code>lynse/api/native_api/high_level.py</code> <pre><code>def database_exists(self):\n    \"\"\"\n    Check if the database exists.\n\n    Returns:\n        (Bool): Whether the database exists.\n    \"\"\"\n    return self._root_path.exists()\n</code></pre>"},{"location":"native_api/high_level/#lynse.api.native_api.high_level.LocalClient.drop_collection","title":"<code>drop_collection(collection)</code>","text":"<p>Delete a collection from the database.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str</code> <p>The name of the collection to delete.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>lynse/api/native_api/high_level.py</code> <pre><code>@unavailable_if_deleted\ndef drop_collection(self, collection: str):\n    \"\"\"\n    Delete a collection from the database.\n\n    Parameters:\n        collection (str): The name of the collection to delete.\n\n    Returns:\n        None\n    \"\"\"\n\n    if collection in self._collections:\n        self._collections[collection].delete()\n        del self._collections[collection]\n        self._register.deregister_collection(collection)\n    else:\n        try:\n            _temp_collection = self.get_collection(collection)\n            self.drop_collection(collection)\n        except ValueError:\n            pass\n\n    if (self._root_path / \"collections.json\").exists():\n        with open(self._root_path / \"collections.json\", \"r\") as f:\n            collections = json.load(f)\n            if collection in collections:\n                del collections[collection]\n\n        with open(self._root_path / \"collections.json\", \"w\") as f:\n            json.dump(collections, f)\n</code></pre>"},{"location":"native_api/high_level/#lynse.api.native_api.high_level.LocalClient.drop_database","title":"<code>drop_database()</code>","text":"<p>Delete the database.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>lynse/api/native_api/high_level.py</code> <pre><code>def drop_database(self):\n    \"\"\"\n    Delete the database.\n\n    Returns:\n        None\n    \"\"\"\n    if self.STATUS == 'DELETED':\n        return\n\n    if self._root_path.exists():\n        shutil.rmtree(self._root_path)\n\n    LocalClient._instance = None\n    self.STATUS = 'DELETED'\n</code></pre>"},{"location":"native_api/high_level/#lynse.api.native_api.high_level.LocalClient.get_collection","title":"<code>get_collection(collection, cache_chunks=20, warm_up=True)</code>","text":"<p>Get a collection from the database.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str</code> <p>The name of the collection to get.</p> required <code>cache_chunks</code> <code>int</code> <p>The number of chunks to cache. Default is 20.</p> <code>20</code> <code>warm_up</code> <code>bool</code> <p>Whether to warm up the database. Default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>ExclusiveDB</code> <p>The collection.</p> Source code in <code>lynse/api/native_api/high_level.py</code> <pre><code>@unavailable_if_deleted\ndef get_collection(self, collection: str, cache_chunks: int = 20, warm_up: bool = True):\n    \"\"\"\n    Get a collection from the database.\n\n    Parameters:\n        collection (str): The name of the collection to get.\n        cache_chunks (int): The number of chunks to cache. Default is 20.\n        warm_up (bool): Whether to warm up the database. Default is True.\n\n    Returns:\n        (ExclusiveDB): The collection.\n    \"\"\"\n    from ...api.native_api.low_level import ExclusiveDB\n\n    if collection not in self._collections:\n        if collection not in self._register:\n            raise ValueError(f\"Collection '{collection}' does not exist.\")\n\n        params = self._register.get_collections_details()[collection]\n        params.update({'cache_chunks': cache_chunks, 'warm_up': warm_up})\n        if 'description' in params:\n            del params['description']\n        self._collections[collection] = ExclusiveDB(**params)\n\n    return self._collections[collection]\n</code></pre>"},{"location":"native_api/high_level/#lynse.api.native_api.high_level.LocalClient.require_collection","title":"<code>require_collection(collection, dim=None, chunk_size=100000, dtypes='float32', use_cache=True, n_threads=10, warm_up=False, drop_if_exists=False, description=None, cache_chunks=20)</code>","text":"<p>Create or load a collection in the database.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str</code> <p>The name of the collection.</p> required <code>dim</code> <code>int</code> <p>Dimension of the vectors. Default is None. When creating a new collection, the dimension of the vectors must be specified. When loading an existing collection, the dimension of the vectors is automatically loaded.</p> <code>None</code> <code>chunk_size</code> <code>int</code> <p>The size of each data chunk. Default is 100_000.</p> <code>100000</code> <code>dtypes</code> <code>str</code> <p>The data type of the vectors. Default is 'float32'. Options are 'float16', 'float32' or 'float64'.</p> <code>'float32'</code> <code>use_cache</code> <code>bool</code> <p>Whether to use cache for search. Default is True.</p> <code>True</code> <code>n_threads</code> <code>int</code> <p>The number of threads to use for parallel processing. Default is 10.</p> <code>10</code> <code>warm_up</code> <code>bool</code> <p>Whether to warm up the database. Default is False.</p> <code>False</code> <code>drop_if_exists</code> <code>bool</code> <p>Whether to drop the collection if it already exists. Default is False.</p> <code>False</code> <code>description</code> <code>str</code> <p>A description of the collection. Default is None. The description is limited to 500 characters.</p> <code>None</code> <code>cache_chunks</code> <code>int</code> <p>The number of chunks to cache. Default is 20.</p> <code>20</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>chunk_size</code> is less than or equal to 1.</p> Source code in <code>lynse/api/native_api/high_level.py</code> <pre><code>def require_collection(\n        self,\n        collection: str,\n        dim: int = None,\n        chunk_size: int = 100_000,\n        dtypes: str = 'float32',\n        use_cache: bool = True,\n        n_threads: Union[int, None] = 10,\n        warm_up: bool = False,\n        drop_if_exists: bool = False,\n        description: str = None,\n        cache_chunks: int = 20\n):\n    \"\"\"Create or load a collection in the database.\n\n    Parameters:\n        collection (str): The name of the collection.\n        dim (int): Dimension of the vectors. Default is None.\n            When creating a new collection, the dimension of the vectors must be specified.\n            When loading an existing collection, the dimension of the vectors is automatically loaded.\n        chunk_size (int): The size of each data chunk. Default is 100_000.\n        dtypes (str): The data type of the vectors. Default is 'float32'.\n            Options are 'float16', 'float32' or 'float64'.\n        use_cache (bool): Whether to use cache for search. Default is True.\n        n_threads (int): The number of threads to use for parallel processing. Default is 10.\n        warm_up (bool): Whether to warm up the database. Default is False.\n        drop_if_exists (bool): Whether to drop the collection if it already exists. Default is False.\n        description (str): A description of the collection. Default is None.\n            The description is limited to 500 characters.\n        cache_chunks (int): The number of chunks to cache. Default is 20.\n\n    Raises:\n        ValueError: If `chunk_size` is less than or equal to 1.\n    \"\"\"\n    from ...api.native_api.low_level import ExclusiveDB\n\n    collection_path = self._root_path / collection\n\n    if description is not None and not isinstance(description, str):\n        raise ValueError('Description must be a string')\n    elif description is not None and len(description) &gt; 500:\n        raise ValueError('Description must be less than 500 characters')\n\n    if collection in self._register:\n        if drop_if_exists:\n            self.drop_collection(collection)\n            logger.info(f\"Collection '{collection}' already exists. Dropped.\")\n        else:\n            collection_details = self._register.get_collections_details()[collection]\n            dim = collection_details['dim']\n            logger.info(f\"Collection '{collection}' already exists. Loaded.\")\n\n    if chunk_size &lt;= 1:\n        raise ValueError('chunk_size must be greater than 1')\n\n    self._collections[collection] = ExclusiveDB(\n        dim=dim, database_path=collection_path.as_posix(), chunk_size=chunk_size, dtypes=dtypes,\n        use_cache=use_cache, n_threads=n_threads,\n        warm_up=warm_up, cache_chunks=cache_chunks\n    )\n\n    self._register.register_collection(\n        collection, dim=dim, database_path=collection_path.as_posix(), chunk_size=chunk_size, dtypes=dtypes,\n        use_cache=use_cache, n_threads=n_threads,\n        warm_up=warm_up, description=description, cache_chunks=cache_chunks\n    )\n\n    self._collections[collection].update_description = partial(self.update_collection_description, collection)\n\n    return self._collections[collection]\n</code></pre>"},{"location":"native_api/high_level/#lynse.api.native_api.high_level.LocalClient.show_collections","title":"<code>show_collections()</code>","text":"<p>Show the collections in the database.</p> <p>Returns:</p> Name Type Description <code>List</code> <p>The list of collections in the database.</p> Source code in <code>lynse/api/native_api/high_level.py</code> <pre><code>@unavailable_if_deleted\ndef show_collections(self):\n    \"\"\"\n    Show the collections in the database.\n\n    Returns:\n        List: The list of collections in the database.\n    \"\"\"\n    return self._register.show_collections()\n</code></pre>"},{"location":"native_api/high_level/#lynse.api.native_api.high_level.LocalClient.show_collections_details","title":"<code>show_collections_details()</code>","text":"<p>Show the collections in the database.</p> <p>Returns:</p> Type Description <code>Dict or DataFrame</code> <p>The details of the collections in the database.</p> Source code in <code>lynse/api/native_api/high_level.py</code> <pre><code>def show_collections_details(self):\n    \"\"\"\n    Show the collections in the database.\n\n    Returns:\n        (Dict or DataFrame): The details of the collections in the database.\n    \"\"\"\n    return self._register.show_collections_details()\n</code></pre>"},{"location":"native_api/high_level/#lynse.api.native_api.high_level.LocalClient.update_collection_description","title":"<code>update_collection_description(collection, description)</code>","text":"<p>Update the description of the collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str</code> <p>The name of the collection.</p> required <code>description</code> <code>None or str or int or float or bool</code> <p>The description of the collection.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>lynse/api/native_api/high_level.py</code> <pre><code>def update_collection_description(self, collection: str, description: Union[None, str, int, float, bool]):\n    \"\"\"\n    Update the description of the collection.\n\n    Parameters:\n        collection (str): The name of the collection.\n        description (None or str or int or float or bool): The description of the collection.\n\n    Returns:\n        None\n    \"\"\"\n    self._register.update_description(collection, description)\n</code></pre>"},{"location":"native_api/low_level/","title":"ExclusiveDB API","text":""},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB","title":"<code>ExclusiveDB</code>","text":"<p>A class for managing a vector database stored in chunk files and computing vectors similarity. The class is exclusive and cannot be shared with other threads or processes, so it is not thread-safe or process-safe.</p> Note <p>This class is not called at the top level, but is called through the LocalClient class. When directly operating on data by calling this class, users need to be clear about what they are doing.</p> Source code in <code>lynse/api/native_api/low_level.py</code> <pre><code>class ExclusiveDB:\n    \"\"\"\n    A class for managing a vector database stored in chunk files and computing vectors similarity.\n    The class is exclusive and cannot be shared with other threads or processes,\n    so it is not thread-safe or process-safe.\n\n    Note:\n        This class is not called at the top level, but is called through the LocalClient class.\n        When directly operating on data by calling this class, users need to be clear about what they are doing.\n    \"\"\"\n    name = \"Local\"\n\n    @ParametersValidator(\n        immutable_param=['dim', 'chunk_size', 'dtypes'],\n        logger=logger\n    )\n    @ParameterTypeAssert({\n        'dim': int,\n        'database_path': str,\n        'chunk_size': int,\n        'dtypes': str,\n        'use_cache': bool,\n        'n_threads': (None, int),\n        'warm_up': bool,\n        'cache_chunks': int\n    }, func_name='ExclusiveDB')\n    def __init__(\n            self,\n            dim: int,\n            database_path: Union[str, Path],\n            chunk_size: int = 100_000,\n            dtypes: str = 'float32',\n            use_cache: bool = True,\n            n_threads: Union[int, None] = 10,\n            warm_up: bool = False,\n            cache_chunks: int = 20\n    ):\n        \"\"\"\n        Initialize the vector database.\n\n        Parameters:\n            dim (int): Dimension of the vectors.\n            database_path (str or Path): The path to the database file.\n            chunk_size (int): The size of each data chunk. Default is 100,000.\n                It's recommended to be between 10,000 and 500,000.\n            dtypes (str): The data type of the vectors. Default is 'float32'.\n                Options are 'float16', 'float32' or 'float64'.\n            use_cache (bool): Whether to use cache for search. Default is True.\n            n_threads (int): The number of threads to use for parallel processing. Default is 10.\n            warm_up (bool): Whether to warm up the database. Default is False.\n            cache_chunks (int): The number of chunks to cache in memory. Default is 20.\n\n        Raises:\n            ValueError: If `chunk_size` is less than or equal to 1.\n        \"\"\"\n        raise_if(ValueError, chunk_size &lt;= 1, 'chunk_size must greater than 1')\n        raise_if(ValueError, dtypes not in ('float16', 'float32', 'float64'),\n                 'dtypes must be \"float16\", \"float32\" or \"float64')\n\n        if chunk_size &lt;= 1:\n            raise ValueError('chunk_size must be greater than 1')\n\n        if not 10000 &lt;= chunk_size &lt;= 500000:\n            logger.warning('The recommended chunk size is between 10,000 and 500,000.')\n\n        # In order to have enough data to index the segment\n        raise_if(ValueError, chunk_size &lt; 1000, 'chunk_size must greater than or equal to 1000.')\n\n        self._database_path = database_path\n        self._database_name = Path(database_path).parent.name\n        self._collection_name = Path(database_path).name\n\n        self._matrix_serializer = MatrixSerializer(\n            dim=dim,\n            collection_path=self._database_path,\n            chunk_size=chunk_size,\n            logger=logger,\n            dtypes=dtypes,\n            warm_up=warm_up,\n            cache_chunks=cache_chunks\n        )\n        self._data_loader = self._matrix_serializer.dataloader\n        self._id_filter = self._matrix_serializer.id_filter\n\n        self._timer = Timer()\n        self._use_cache = use_cache\n\n        raise_if(TypeError, n_threads is not None and not isinstance(n_threads, int), \"n_threads must be an integer.\")\n        raise_if(ValueError, n_threads is not None and n_threads &lt;= 0, \"n_threads must be greater than 0.\")\n\n        self._indexer = Indexer(\n            logger=logger,\n            dataloader=self._data_loader,\n            storage_worker=self._matrix_serializer.storage_worker,\n            collections_path_parent=self._matrix_serializer.collections_path_parent\n        )\n\n        self._search = Search(\n            matrix_serializer=self._matrix_serializer,\n            n_threads=n_threads if n_threads else min(32, os.cpu_count() + 4),\n        )\n\n        self._search.single_search.clear_cache()\n\n        # initial lock\n        self._lock = ThreadLock()\n\n        # pre_build_index if the ExclusiveDB instance is reloaded\n        if self.shape[0] &gt; 0:\n            self._pre_build_index()\n\n    @unavailable_if_deleted\n    def add_item(self, vector: Union[np.ndarray, list], id: int, *, field: dict = None,\n                 buffer_size: Union[int, None, bool] = True):\n        \"\"\"\n        Add a single vector to the collection.\n\n        It is recommended to use incremental ids for best performance.\n\n        Parameters:\n            vector (np.ndarray): The vector to be added.\n            id (int): The ID of the vector.\n            field (dict, optional, keyword-only): The field of the vector. Default is None.\n                If None, the field will be set to an empty string.\n            buffer_size (int or bool or None): The buffer size for the storage worker. Default is True.\n\n                - If None, the vector will be directly written to the disk.\n                - If True, the buffer_size will be set to chunk_size,\n                    and the vectors will be written to the disk when the buffer is full.\n                - If False, the vector will be directly written to the disk.\n                - If int, when the buffer is full, the vectors will be written to the disk.\n\n        Returns:\n            (int): The ID of the added vector.\n\n        Raises:\n            ValueError: If the vector dimensions don't match or the ID already exists.\n        \"\"\"\n        return self._matrix_serializer.add_item(vector, id=id, field=field,\n                                                buffer_size=buffer_size)\n\n    @unavailable_if_deleted\n    def bulk_add_items(\n            self, vectors: Union[List[Tuple[np.ndarray, int, dict]], List[Tuple[np.ndarray, int]]],\n            **kwargs\n    ):\n        \"\"\"\n        Bulk add vectors to the collection in batches.\n\n        It is recommended to use incremental ids for best performance.\n\n        Parameters:\n            vectors (list or tuple): A list or tuple of vectors to be saved.\n                Each vector can be a tuple of (vector, id, field).\n\n        Returns:\n            List[int]: A list of indices where the vectors are stored.\n        \"\"\"\n        return self._matrix_serializer.bulk_add_items(vectors)\n\n    @unavailable_if_deleted\n    def commit(self):\n        \"\"\"\n        Save the database, ensuring that all data is written to disk.\n        \"\"\"\n        with self._lock:\n            self._matrix_serializer.commit()\n            self._pre_build_index()\n\n    @unavailable_if_deleted\n    def _pre_build_index(self):\n        if not hasattr(self._matrix_serializer, \"indexer\"):\n            logger.info(\"Pre-building the index...\")\n            self.build_index(index_mode=\"Flat-IP\")  # Default index mode\n\n    @unavailable_if_deleted\n    @unavailable_if_empty\n    def build_index(self, index_mode, rebuild=False, **kwargs):\n        \"\"\"\n        Build the index for clustering.\n\n        Parameters:\n            index_mode (str): The index mode, must be one of the following:\n\n                - 'IVF-IP-SQ8': IVF index with inner product and scalar quantizer with 8 bits.\n                    The distance is inner product.\n                - 'IVF-IP': IVF index with inner product. (Alias: 'IVF')\n                - 'IVF-L2sq-SQ8': IVF index with squared L2 distance and scalar quantizer with 8 bits.\n                    The distance is squared L2 distance.\n                - 'IVF-L2sq': IVF index with squared L2 distance.\n                - 'IVF-Cos-SQ8': IVF index with cosine similarity and scalar quantizer with 8 bits.\n                    The distance is cosine similarity.\n                - 'IVF-Cos': IVF index with cosine similarity.\n                - 'IVF-Jaccard-Binary': IVF index with binary quantizer. The distance is Jaccard distance.\n                - 'IVF-Hamming-Binary': IVF index with binary quantizer. The distance is Hamming distance.\n                - 'Flat-IP-SQ8': Flat index with inner product and scalar quantizer with 8 bits.\n                - 'Flat-IP': Flat index with inner product. (Alias: 'FLAT')\n                - 'Flat-L2sq-SQ8': Flat index with squared L2 distance and scalar quantizer with 8 bits.\n                - 'Flat-L2sq': Flat index with squared L2 distance.\n                - 'Flat-Cos-SQ8': Flat index with cosine similarity and scalar quantizer with 8 bits.\n                - 'Flat-Cos': Flat index with cosine similarity.\n                - 'Flat-Jaccard-Binary': Flat index with binary quantizer. The distance is Jaccard distance.\n                - 'Flat-Hamming-Binary': Flat index with binary quantizer. The distance is Hamming distance.\n            rebuild (bool): Whether to rebuild the index.\n            kwargs: Additional keyword arguments. The following are available:\n\n                - 'n_clusters' (int): The number of clusters. It is only available when the index_mode including 'IVF'.\n\n        Returns:\n            None\n        \"\"\"\n        with self._lock:\n            self._indexer.build_index(index_mode, rebuild=rebuild, **kwargs)\n            self._matrix_serializer.indexer = self._indexer\n\n    @unavailable_if_deleted\n    @unavailable_if_empty\n    def remove_index(self):\n        \"\"\"\n        Remove the vector index.\n\n        Returns:\n            None\n        \"\"\"\n        self._indexer.remove_index()\n        logger.info(\"Fallback to default index mode: `Flat-IP`.\")\n        self.build_index(index_mode='Flat-IP')  # Default index mode\n\n    @unavailable_if_deleted\n    @unavailable_if_empty\n    def search(self, vector: Union[np.ndarray, list], k: int = 10, *,\n               search_filter: Filter = None, return_fields=False, **kwargs):\n        \"\"\"\n        Search the database for the vectors most similar to the given vector.\n\n        Parameters:\n            vector (np.ndarray or list): The search vectors, it can be a single vector or a list of vectors.\n                The vectors must have the same dimension as the vectors in the database,\n                and the type of vector can be a list or a numpy array.\n            k (int): The number of nearest vectors to return.\n            search_filter (Filter or FilterExpression string, optional): The filter to apply to the search.\n            return_fields (bool): Whether to return the fields of the search results.\n            kwargs: Additional keyword arguments. The following are valid:\n\n                - rescore (bool): Whether to rescore the results of binary or scaler quantization searches.\n                    Default is False. It is recommended to set it to True when the index mode is 'Binary'.\n                - rescore_multiplier (int): The multiplier for the rescore operation.\n                    It is only available when rescore is True.\n                    If 'Binary' is in the index mode, the default is 10. Otherwise, the default is 2.\n\n        Returns:\n            (Tuple[List[int], List[float], List[Dict]] or Tuple[List[int], List[float], None]):\n                If return_fields is True, the indices, similarity scores,\n                and fields of the nearest vectors in the database.\n                Otherwise, the indices and similarity scores of the nearest vectors in the database.\n\n        Raises:\n            ValueError: If the database is empty.\n        \"\"\"\n        raise_if(ValueError, not isinstance(vector, (np.ndarray, list)),\n                 'vector must be np.ndarray or list.')\n\n        raise_if(TypeError, not isinstance(k, int) and not (isinstance(k, str) and k != 'all'),\n                 'k must be int or \"all\".')\n        raise_if(ValueError, k &lt;= 0, 'k must be greater than 0.')\n        raise_if(ValueError, not isinstance(search_filter, (Filter, type(None), str)),\n                 'search_filter must be Filter or None or FieldExpression string.')\n\n        # Convert the vector to np.ndarray\n        vector = np.atleast_2d(np.asarray(vector))\n\n        raise_if(ValueError, vector.shape[1] != self._matrix_serializer.shape[1],\n                 'vector must be same dim with database.')\n\n        rescore = kwargs.setdefault('rescore', False)\n        rescore_multiplier = kwargs.setdefault('rescore_multiplier', 2)\n        raise_if(TypeError, not isinstance(rescore, bool), 'rescore must be bool.')\n        raise_if(TypeError, not isinstance(rescore_multiplier, int), 'rescore_multiplier must be int.')\n\n        if self._matrix_serializer.shape[0] == 0:\n            raise ValueError('database is empty.')\n\n        if k &gt; self._matrix_serializer.shape[0]:\n            k = self._matrix_serializer.shape[0]\n\n        if not self._use_cache:\n            self._search.single_search.clear_cache()\n\n        res = self._search.search(vector=vector, k=k, search_filter=search_filter,\n                                  return_fields=return_fields, **kwargs)\n\n        return res\n\n    @unavailable_if_deleted\n    def is_id_exists(self, id):\n        \"\"\"\n        Check if the ID exists in the database.\n\n        Parameters:\n            id (int): The ID to check.\n\n        Returns:\n            Bool: True if the ID exists, False otherwise.\n        \"\"\"\n        return id in self._matrix_serializer.id_filter\n\n    @property\n    @unavailable_if_deleted\n    @unavailable_if_empty\n    def max_id(self):\n        \"\"\"\n        Return the maximum ID in the database.\n\n        Returns:\n            (int): The maximum ID in the database.\n        \"\"\"\n        return self._matrix_serializer.id_filter.find_max_value()\n\n    @unavailable_if_deleted\n    @unavailable_if_empty\n    def query(self, query_filter, filter_ids=None, return_ids_only=False):\n        \"\"\"\n        Query the fields cache.\n\n        Parameters:\n            query_filter (str): Filter or dict or FieldExpression string\n                The filter object or the specify data to filter.\n            filter_ids (List[int]):\n                The list of external IDs to filter.\n            return_ids_only (bool):\n                If True, only the external IDs will be returned.\n\n        Returns:\n            (List[Dict]): The records. If not return_ids_only, the records will be returned.\n            (List[int]): The external IDs. If return_ids_only, the external IDs will be returned.\n        \"\"\"\n        return self._matrix_serializer.field_index.query(query_filter, filter_ids, return_ids_only)\n\n    @unavailable_if_deleted\n    @unavailable_if_empty\n    def query_vectors(self, query_filter, filter_ids=None):\n        \"\"\"\n        Query the vector data by the filter.\n\n        Parameters:\n            query_filter (Filter or dict or FieldExpression str or None):\n                The filter object or the specify data to filter.\n            filter_ids (list[int]):\n                The list of external IDs to filter. Default is None.\n\n        Returns:\n            (Tuple[List[np.ndarray], List[int], List[Dict]]): The vectors, IDs, and fields of the items.\n        \"\"\"\n        ids = self._matrix_serializer.field_index.query(query_filter, filter_ids, return_ids_only=True)\n        if not ids:\n            return np.array([]), np.array([]), []\n\n        return self.read_by_only_id(ids)\n\n    @property\n    def shape(self):\n        \"\"\"\n        Return the shape of the entire database.\n\n        Returns:\n            (Tuple[int, int]): The number of vectors and the dimension of each vector in the database.\n        \"\"\"\n        return self._matrix_serializer.shape\n\n    @unavailable_if_deleted\n    def insert_session(self):\n        \"\"\"\n        Create a session to insert data, which will automatically commit the data when the session ends.\n\n        Returns:\n            DataOpsSession (DataOpsSession): The session object.\n        \"\"\"\n        from ...execution_layer.session import DataOpsSession\n\n        return DataOpsSession(self)\n\n    @unavailable_if_deleted\n    @unavailable_if_empty\n    def head(self, n=5):\n        \"\"\"\n        Return the first n vectors in the database.\n\n        Parameters:\n            n (int): The number of vectors to return. Default is 5.\n\n        Returns:\n            (Tuple[List[np.ndarray], List[int], List[Dict]]): The vectors, IDs, and fields of the items.\n        \"\"\"\n        filenames = self._matrix_serializer.storage_worker.get_all_files()\n        filenames = sorted(filenames, key=lambda x: int(x.split('_')[-1].split('.')[0]))\n\n        data, indices = [], []\n\n        count = 0\n        dtypes = self._matrix_serializer.dtypes\n\n        for filename in filenames:\n            data_chunk, index_chunk = self._matrix_serializer.dataloader(filename)\n            dtypes = data_chunk.dtype\n            data.extend(data_chunk)\n            indices.extend(index_chunk)\n            count += len(index_chunk)\n            if count &gt;= n:\n                break\n\n        if data:\n            return (np.asarray(indices)[:n], np.vstack(data, dtype=dtypes)[:n],\n                    self._matrix_serializer.field_index.retrieve_ids(indices[:n],\n                                                                     include_external_id=True))\n        return np.asarray(indices), np.array(data, dtype=dtypes), []\n\n    @unavailable_if_deleted\n    @unavailable_if_empty\n    def tail(self, n=5):\n        \"\"\"\n        Return the last n vectors in the database.\n\n        Parameters:\n            n (int): The number of vectors to return. Default is 5.\n\n        Returns:\n            (Tuple[List[np.ndarray], List[int], List[Dict]]): The vectors, IDs, and fields of the items.\n        \"\"\"\n        filenames = self._matrix_serializer.storage_worker.get_all_files()\n        filenames = sorted(filenames, key=lambda x: int(x.split('_')[-1].split('.')[0]))\n\n        data, indices = [], []\n\n        count = 0\n        dtypes = self._matrix_serializer.dtypes\n\n        for filename in filenames[::-1]:\n            data_chunk, index_chunk = self._matrix_serializer.dataloader(filename)\n            dtypes = data_chunk.dtype\n            data.insert(0, data_chunk)\n            indices = index_chunk.tolist() + indices\n            count += len(index_chunk)\n            if count &gt;= n:\n                break\n\n        if data:\n            return (np.asarray(indices)[-n:], np.vstack(data, dtype=dtypes)[-n:],\n                    self._matrix_serializer.field_index.retrieve_ids(indices[-n:],\n                                                                     include_external_id=True))\n        return np.asarray(indices), np.array(data, dtype=dtypes), []\n\n    @unavailable_if_deleted\n    @unavailable_if_empty\n    def yield_every_single_element(self, limit=None):\n        \"\"\"\n        Yield every single element in the database.\n\n        Parameters:\n            limit (int): The maximum number of elements to yield. Default is None.\n\n        Returns:\n            (Tuple[np.ndarray, int, Dict]): The vectors, IDs, and fields of the items\n\n        \"\"\"\n        raise_if(TypeError, limit is not None and not isinstance(limit, int), \"limit must be an integer.\")\n        filenames = self._matrix_serializer.storage_worker.get_all_files()\n        filenames = sorted(filenames, key=lambda x: int(x.split('_')[-1].split('.')[0]))\n\n        count = 0\n        for filename in filenames:\n            data_chunk, index_chunk = self._matrix_serializer.dataloader(filename)\n            for i in range(len(index_chunk)):\n                yield int(index_chunk[i]), np.asarray(data_chunk[i]), \\\n                    self._matrix_serializer.field_index.retrieve([index_chunk[i]], include_external_id=True)\n                count += 1\n                if limit and count &gt;= limit:\n                    return\n\n    @unavailable_if_deleted\n    @unavailable_if_empty\n    def read_by_only_id(self, id: Union[int, list]):\n        \"\"\"\n        Read the vector data by the external ID.\n\n        Parameters:\n            id (int or list): The external ID or list of external IDs.\n\n        Returns:\n            (Tuple[np.ndarray, List[int], List[Dict]], Tuple[np.ndarray, int, Dict]):\n                The vectors, IDs, and fields of the items.\n        \"\"\"\n        data, ids = self._matrix_serializer.storage_worker.read_by_only_id(id)\n\n        if data.shape[0] &gt; 0:\n            return np.asarray(ids), np.asarray(data), \\\n                self._matrix_serializer.field_index.retrieve_ids(ids, include_external_id=True)\n        return np.asarray(ids), np.asarray(data), []\n\n    @unavailable_if_deleted\n    @unavailable_if_empty\n    def list_fields(self):\n        \"\"\"\n        Return all field names and their types.\n\n        Returns:\n            Dict: A dictionary with field names as keys and field types as values.\n        \"\"\"\n        return self._matrix_serializer.field_index.storage.list_fields()\n\n    @unavailable_if_deleted\n    @unavailable_if_empty\n    def build_field_index(self, schema, rebuild_if_exists=False):\n        \"\"\"\n        Build an index for the field.\n\n        Parameters:\n            schema (IndexSchema or Field name string): The schema of the field or the field name string.\n                When passing the field name string, the field name must be wrapped with ':', like ':vector:', ':timestamp:'.\n            rebuild_if_exists (bool): Whether to rebuild the index if it already exists.\n\n        Returns:\n            None\n\n        Note:\n            The :id: is a reserved field name and cannot be used.\n        \"\"\"\n        if not isinstance(schema, (IndexSchema, str)):\n            raise TypeError(\"schema must be an instance of IndexSchema or a field string.\")\n        self._matrix_serializer.field_index.build_index(schema, rebuild_if_exists=rebuild_if_exists)\n\n    @unavailable_if_deleted\n    @unavailable_if_empty\n    def remove_field_index(self, field_name):\n        \"\"\"\n        Remove the index for the field.\n\n        Parameters:\n            field_name (str): The name of the field.\n\n        Returns:\n            None\n        \"\"\"\n        if not field_name.startswith(':') or not field_name.endswith(':'):\n            raise ValueError(\"The field name must be wrapped with ':'.\")\n\n        field_name = field_name.strip(':')\n        self._matrix_serializer.field_index.remove_index(field_name)\n\n    @unavailable_if_deleted\n    @unavailable_if_empty\n    def remove_all_field_indices(self):\n        \"\"\"\n        Remove all the field indices.\n\n        Returns:\n            None\n        \"\"\"\n        self._matrix_serializer.field_index.remove_all_field_indices()\n\n    @unavailable_if_deleted\n    @unavailable_if_empty\n    def list_field_index(self):\n        \"\"\"\n        List the field index.\n\n        Returns:\n            List: The list of field indices.\n        \"\"\"\n        return self._matrix_serializer.field_index.list_indices()\n\n    def delete(self):\n        \"\"\"\n        Delete the database.\n\n        This API is not part of the Collection in the HTTP API, but rather part of the HTTPClient in the HTTP API\n        Users must call this API through the HTTPClient when they want to delete a collection on the server.\n\n        Returns:\n            None\n        \"\"\"\n        if self._matrix_serializer.IS_DELETED:\n            return\n\n        import gc\n\n        with self._lock:\n            self._search.single_search.clear_cache()\n            self._search.delete()\n            self._matrix_serializer.delete()\n\n        gc.collect()\n\n    @property\n    @unavailable_if_empty\n    def index_mode(self):\n        \"\"\"\n        Return the index mode of the database.\n\n        Returns:\n            (str or None): The index mode of the database.\n        \"\"\"\n        if not hasattr(self._matrix_serializer, \"indexer\"):\n            return None\n\n        return self._matrix_serializer.indexer.index_mode\n\n    def is_deleted(self):\n        \"\"\"\n        To check if the database is deleted.\n\n        Returns:\n            Bool: True if the database is deleted, False otherwise.\n        \"\"\"\n        return self._matrix_serializer.IS_DELETED\n\n    def __len__(self):\n        return self.shape[0]\n\n    def __repr__(self):\n        return collection_repr(self)\n\n    def __str__(self):\n        return self.__repr__()\n</code></pre>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.index_mode","title":"<code>index_mode</code>  <code>property</code>","text":"<p>Return the index mode of the database.</p> <p>Returns:</p> Type Description <code>str or None</code> <p>The index mode of the database.</p>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.max_id","title":"<code>max_id</code>  <code>property</code>","text":"<p>Return the maximum ID in the database.</p> <p>Returns:</p> Type Description <code>int</code> <p>The maximum ID in the database.</p>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Return the shape of the entire database.</p> <p>Returns:</p> Type Description <code>Tuple[int, int]</code> <p>The number of vectors and the dimension of each vector in the database.</p>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.__init__","title":"<code>__init__(dim, database_path, chunk_size=100000, dtypes='float32', use_cache=True, n_threads=10, warm_up=False, cache_chunks=20)</code>","text":"<p>Initialize the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Dimension of the vectors.</p> required <code>database_path</code> <code>str or Path</code> <p>The path to the database file.</p> required <code>chunk_size</code> <code>int</code> <p>The size of each data chunk. Default is 100,000. It's recommended to be between 10,000 and 500,000.</p> <code>100000</code> <code>dtypes</code> <code>str</code> <p>The data type of the vectors. Default is 'float32'. Options are 'float16', 'float32' or 'float64'.</p> <code>'float32'</code> <code>use_cache</code> <code>bool</code> <p>Whether to use cache for search. Default is True.</p> <code>True</code> <code>n_threads</code> <code>int</code> <p>The number of threads to use for parallel processing. Default is 10.</p> <code>10</code> <code>warm_up</code> <code>bool</code> <p>Whether to warm up the database. Default is False.</p> <code>False</code> <code>cache_chunks</code> <code>int</code> <p>The number of chunks to cache in memory. Default is 20.</p> <code>20</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>chunk_size</code> is less than or equal to 1.</p> Source code in <code>lynse/api/native_api/low_level.py</code> <pre><code>@ParametersValidator(\n    immutable_param=['dim', 'chunk_size', 'dtypes'],\n    logger=logger\n)\n@ParameterTypeAssert({\n    'dim': int,\n    'database_path': str,\n    'chunk_size': int,\n    'dtypes': str,\n    'use_cache': bool,\n    'n_threads': (None, int),\n    'warm_up': bool,\n    'cache_chunks': int\n}, func_name='ExclusiveDB')\ndef __init__(\n        self,\n        dim: int,\n        database_path: Union[str, Path],\n        chunk_size: int = 100_000,\n        dtypes: str = 'float32',\n        use_cache: bool = True,\n        n_threads: Union[int, None] = 10,\n        warm_up: bool = False,\n        cache_chunks: int = 20\n):\n    \"\"\"\n    Initialize the vector database.\n\n    Parameters:\n        dim (int): Dimension of the vectors.\n        database_path (str or Path): The path to the database file.\n        chunk_size (int): The size of each data chunk. Default is 100,000.\n            It's recommended to be between 10,000 and 500,000.\n        dtypes (str): The data type of the vectors. Default is 'float32'.\n            Options are 'float16', 'float32' or 'float64'.\n        use_cache (bool): Whether to use cache for search. Default is True.\n        n_threads (int): The number of threads to use for parallel processing. Default is 10.\n        warm_up (bool): Whether to warm up the database. Default is False.\n        cache_chunks (int): The number of chunks to cache in memory. Default is 20.\n\n    Raises:\n        ValueError: If `chunk_size` is less than or equal to 1.\n    \"\"\"\n    raise_if(ValueError, chunk_size &lt;= 1, 'chunk_size must greater than 1')\n    raise_if(ValueError, dtypes not in ('float16', 'float32', 'float64'),\n             'dtypes must be \"float16\", \"float32\" or \"float64')\n\n    if chunk_size &lt;= 1:\n        raise ValueError('chunk_size must be greater than 1')\n\n    if not 10000 &lt;= chunk_size &lt;= 500000:\n        logger.warning('The recommended chunk size is between 10,000 and 500,000.')\n\n    # In order to have enough data to index the segment\n    raise_if(ValueError, chunk_size &lt; 1000, 'chunk_size must greater than or equal to 1000.')\n\n    self._database_path = database_path\n    self._database_name = Path(database_path).parent.name\n    self._collection_name = Path(database_path).name\n\n    self._matrix_serializer = MatrixSerializer(\n        dim=dim,\n        collection_path=self._database_path,\n        chunk_size=chunk_size,\n        logger=logger,\n        dtypes=dtypes,\n        warm_up=warm_up,\n        cache_chunks=cache_chunks\n    )\n    self._data_loader = self._matrix_serializer.dataloader\n    self._id_filter = self._matrix_serializer.id_filter\n\n    self._timer = Timer()\n    self._use_cache = use_cache\n\n    raise_if(TypeError, n_threads is not None and not isinstance(n_threads, int), \"n_threads must be an integer.\")\n    raise_if(ValueError, n_threads is not None and n_threads &lt;= 0, \"n_threads must be greater than 0.\")\n\n    self._indexer = Indexer(\n        logger=logger,\n        dataloader=self._data_loader,\n        storage_worker=self._matrix_serializer.storage_worker,\n        collections_path_parent=self._matrix_serializer.collections_path_parent\n    )\n\n    self._search = Search(\n        matrix_serializer=self._matrix_serializer,\n        n_threads=n_threads if n_threads else min(32, os.cpu_count() + 4),\n    )\n\n    self._search.single_search.clear_cache()\n\n    # initial lock\n    self._lock = ThreadLock()\n\n    # pre_build_index if the ExclusiveDB instance is reloaded\n    if self.shape[0] &gt; 0:\n        self._pre_build_index()\n</code></pre>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.add_item","title":"<code>add_item(vector, id, *, field=None, buffer_size=True)</code>","text":"<p>Add a single vector to the collection.</p> <p>It is recommended to use incremental ids for best performance.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>ndarray</code> <p>The vector to be added.</p> required <code>id</code> <code>int</code> <p>The ID of the vector.</p> required <code>field</code> <code>(dict, optional, keyword - only)</code> <p>The field of the vector. Default is None. If None, the field will be set to an empty string.</p> <code>None</code> <code>buffer_size</code> <code>int or bool or None</code> <p>The buffer size for the storage worker. Default is True.</p> <ul> <li>If None, the vector will be directly written to the disk.</li> <li>If True, the buffer_size will be set to chunk_size,     and the vectors will be written to the disk when the buffer is full.</li> <li>If False, the vector will be directly written to the disk.</li> <li>If int, when the buffer is full, the vectors will be written to the disk.</li> </ul> <code>True</code> <p>Returns:</p> Type Description <code>int</code> <p>The ID of the added vector.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the vector dimensions don't match or the ID already exists.</p> Source code in <code>lynse/api/native_api/low_level.py</code> <pre><code>@unavailable_if_deleted\ndef add_item(self, vector: Union[np.ndarray, list], id: int, *, field: dict = None,\n             buffer_size: Union[int, None, bool] = True):\n    \"\"\"\n    Add a single vector to the collection.\n\n    It is recommended to use incremental ids for best performance.\n\n    Parameters:\n        vector (np.ndarray): The vector to be added.\n        id (int): The ID of the vector.\n        field (dict, optional, keyword-only): The field of the vector. Default is None.\n            If None, the field will be set to an empty string.\n        buffer_size (int or bool or None): The buffer size for the storage worker. Default is True.\n\n            - If None, the vector will be directly written to the disk.\n            - If True, the buffer_size will be set to chunk_size,\n                and the vectors will be written to the disk when the buffer is full.\n            - If False, the vector will be directly written to the disk.\n            - If int, when the buffer is full, the vectors will be written to the disk.\n\n    Returns:\n        (int): The ID of the added vector.\n\n    Raises:\n        ValueError: If the vector dimensions don't match or the ID already exists.\n    \"\"\"\n    return self._matrix_serializer.add_item(vector, id=id, field=field,\n                                            buffer_size=buffer_size)\n</code></pre>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.build_field_index","title":"<code>build_field_index(schema, rebuild_if_exists=False)</code>","text":"<p>Build an index for the field.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>IndexSchema or Field name string</code> <p>The schema of the field or the field name string. When passing the field name string, the field name must be wrapped with ':', like ':vector:', ':timestamp:'.</p> required <code>rebuild_if_exists</code> <code>bool</code> <p>Whether to rebuild the index if it already exists.</p> <code>False</code> <p>Returns:</p> Type Description <p>None</p> Note <p>The :id: is a reserved field name and cannot be used.</p> Source code in <code>lynse/api/native_api/low_level.py</code> <pre><code>@unavailable_if_deleted\n@unavailable_if_empty\ndef build_field_index(self, schema, rebuild_if_exists=False):\n    \"\"\"\n    Build an index for the field.\n\n    Parameters:\n        schema (IndexSchema or Field name string): The schema of the field or the field name string.\n            When passing the field name string, the field name must be wrapped with ':', like ':vector:', ':timestamp:'.\n        rebuild_if_exists (bool): Whether to rebuild the index if it already exists.\n\n    Returns:\n        None\n\n    Note:\n        The :id: is a reserved field name and cannot be used.\n    \"\"\"\n    if not isinstance(schema, (IndexSchema, str)):\n        raise TypeError(\"schema must be an instance of IndexSchema or a field string.\")\n    self._matrix_serializer.field_index.build_index(schema, rebuild_if_exists=rebuild_if_exists)\n</code></pre>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.build_index","title":"<code>build_index(index_mode, rebuild=False, **kwargs)</code>","text":"<p>Build the index for clustering.</p> <p>Parameters:</p> Name Type Description Default <code>index_mode</code> <code>str</code> <p>The index mode, must be one of the following:</p> <ul> <li>'IVF-IP-SQ8': IVF index with inner product and scalar quantizer with 8 bits.     The distance is inner product.</li> <li>'IVF-IP': IVF index with inner product. (Alias: 'IVF')</li> <li>'IVF-L2sq-SQ8': IVF index with squared L2 distance and scalar quantizer with 8 bits.     The distance is squared L2 distance.</li> <li>'IVF-L2sq': IVF index with squared L2 distance.</li> <li>'IVF-Cos-SQ8': IVF index with cosine similarity and scalar quantizer with 8 bits.     The distance is cosine similarity.</li> <li>'IVF-Cos': IVF index with cosine similarity.</li> <li>'IVF-Jaccard-Binary': IVF index with binary quantizer. The distance is Jaccard distance.</li> <li>'IVF-Hamming-Binary': IVF index with binary quantizer. The distance is Hamming distance.</li> <li>'Flat-IP-SQ8': Flat index with inner product and scalar quantizer with 8 bits.</li> <li>'Flat-IP': Flat index with inner product. (Alias: 'FLAT')</li> <li>'Flat-L2sq-SQ8': Flat index with squared L2 distance and scalar quantizer with 8 bits.</li> <li>'Flat-L2sq': Flat index with squared L2 distance.</li> <li>'Flat-Cos-SQ8': Flat index with cosine similarity and scalar quantizer with 8 bits.</li> <li>'Flat-Cos': Flat index with cosine similarity.</li> <li>'Flat-Jaccard-Binary': Flat index with binary quantizer. The distance is Jaccard distance.</li> <li>'Flat-Hamming-Binary': Flat index with binary quantizer. The distance is Hamming distance.</li> </ul> required <code>rebuild</code> <code>bool</code> <p>Whether to rebuild the index.</p> <code>False</code> <code>kwargs</code> <p>Additional keyword arguments. The following are available:</p> <ul> <li>'n_clusters' (int): The number of clusters. It is only available when the index_mode including 'IVF'.</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>lynse/api/native_api/low_level.py</code> <pre><code>@unavailable_if_deleted\n@unavailable_if_empty\ndef build_index(self, index_mode, rebuild=False, **kwargs):\n    \"\"\"\n    Build the index for clustering.\n\n    Parameters:\n        index_mode (str): The index mode, must be one of the following:\n\n            - 'IVF-IP-SQ8': IVF index with inner product and scalar quantizer with 8 bits.\n                The distance is inner product.\n            - 'IVF-IP': IVF index with inner product. (Alias: 'IVF')\n            - 'IVF-L2sq-SQ8': IVF index with squared L2 distance and scalar quantizer with 8 bits.\n                The distance is squared L2 distance.\n            - 'IVF-L2sq': IVF index with squared L2 distance.\n            - 'IVF-Cos-SQ8': IVF index with cosine similarity and scalar quantizer with 8 bits.\n                The distance is cosine similarity.\n            - 'IVF-Cos': IVF index with cosine similarity.\n            - 'IVF-Jaccard-Binary': IVF index with binary quantizer. The distance is Jaccard distance.\n            - 'IVF-Hamming-Binary': IVF index with binary quantizer. The distance is Hamming distance.\n            - 'Flat-IP-SQ8': Flat index with inner product and scalar quantizer with 8 bits.\n            - 'Flat-IP': Flat index with inner product. (Alias: 'FLAT')\n            - 'Flat-L2sq-SQ8': Flat index with squared L2 distance and scalar quantizer with 8 bits.\n            - 'Flat-L2sq': Flat index with squared L2 distance.\n            - 'Flat-Cos-SQ8': Flat index with cosine similarity and scalar quantizer with 8 bits.\n            - 'Flat-Cos': Flat index with cosine similarity.\n            - 'Flat-Jaccard-Binary': Flat index with binary quantizer. The distance is Jaccard distance.\n            - 'Flat-Hamming-Binary': Flat index with binary quantizer. The distance is Hamming distance.\n        rebuild (bool): Whether to rebuild the index.\n        kwargs: Additional keyword arguments. The following are available:\n\n            - 'n_clusters' (int): The number of clusters. It is only available when the index_mode including 'IVF'.\n\n    Returns:\n        None\n    \"\"\"\n    with self._lock:\n        self._indexer.build_index(index_mode, rebuild=rebuild, **kwargs)\n        self._matrix_serializer.indexer = self._indexer\n</code></pre>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.bulk_add_items","title":"<code>bulk_add_items(vectors, **kwargs)</code>","text":"<p>Bulk add vectors to the collection in batches.</p> <p>It is recommended to use incremental ids for best performance.</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>list or tuple</code> <p>A list or tuple of vectors to be saved. Each vector can be a tuple of (vector, id, field).</p> required <p>Returns:</p> Type Description <p>List[int]: A list of indices where the vectors are stored.</p> Source code in <code>lynse/api/native_api/low_level.py</code> <pre><code>@unavailable_if_deleted\ndef bulk_add_items(\n        self, vectors: Union[List[Tuple[np.ndarray, int, dict]], List[Tuple[np.ndarray, int]]],\n        **kwargs\n):\n    \"\"\"\n    Bulk add vectors to the collection in batches.\n\n    It is recommended to use incremental ids for best performance.\n\n    Parameters:\n        vectors (list or tuple): A list or tuple of vectors to be saved.\n            Each vector can be a tuple of (vector, id, field).\n\n    Returns:\n        List[int]: A list of indices where the vectors are stored.\n    \"\"\"\n    return self._matrix_serializer.bulk_add_items(vectors)\n</code></pre>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.commit","title":"<code>commit()</code>","text":"<p>Save the database, ensuring that all data is written to disk.</p> Source code in <code>lynse/api/native_api/low_level.py</code> <pre><code>@unavailable_if_deleted\ndef commit(self):\n    \"\"\"\n    Save the database, ensuring that all data is written to disk.\n    \"\"\"\n    with self._lock:\n        self._matrix_serializer.commit()\n        self._pre_build_index()\n</code></pre>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.delete","title":"<code>delete()</code>","text":"<p>Delete the database.</p> <p>This API is not part of the Collection in the HTTP API, but rather part of the HTTPClient in the HTTP API Users must call this API through the HTTPClient when they want to delete a collection on the server.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>lynse/api/native_api/low_level.py</code> <pre><code>def delete(self):\n    \"\"\"\n    Delete the database.\n\n    This API is not part of the Collection in the HTTP API, but rather part of the HTTPClient in the HTTP API\n    Users must call this API through the HTTPClient when they want to delete a collection on the server.\n\n    Returns:\n        None\n    \"\"\"\n    if self._matrix_serializer.IS_DELETED:\n        return\n\n    import gc\n\n    with self._lock:\n        self._search.single_search.clear_cache()\n        self._search.delete()\n        self._matrix_serializer.delete()\n\n    gc.collect()\n</code></pre>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.head","title":"<code>head(n=5)</code>","text":"<p>Return the first n vectors in the database.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of vectors to return. Default is 5.</p> <code>5</code> <p>Returns:</p> Type Description <code>Tuple[List[ndarray], List[int], List[Dict]]</code> <p>The vectors, IDs, and fields of the items.</p> Source code in <code>lynse/api/native_api/low_level.py</code> <pre><code>@unavailable_if_deleted\n@unavailable_if_empty\ndef head(self, n=5):\n    \"\"\"\n    Return the first n vectors in the database.\n\n    Parameters:\n        n (int): The number of vectors to return. Default is 5.\n\n    Returns:\n        (Tuple[List[np.ndarray], List[int], List[Dict]]): The vectors, IDs, and fields of the items.\n    \"\"\"\n    filenames = self._matrix_serializer.storage_worker.get_all_files()\n    filenames = sorted(filenames, key=lambda x: int(x.split('_')[-1].split('.')[0]))\n\n    data, indices = [], []\n\n    count = 0\n    dtypes = self._matrix_serializer.dtypes\n\n    for filename in filenames:\n        data_chunk, index_chunk = self._matrix_serializer.dataloader(filename)\n        dtypes = data_chunk.dtype\n        data.extend(data_chunk)\n        indices.extend(index_chunk)\n        count += len(index_chunk)\n        if count &gt;= n:\n            break\n\n    if data:\n        return (np.asarray(indices)[:n], np.vstack(data, dtype=dtypes)[:n],\n                self._matrix_serializer.field_index.retrieve_ids(indices[:n],\n                                                                 include_external_id=True))\n    return np.asarray(indices), np.array(data, dtype=dtypes), []\n</code></pre>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.insert_session","title":"<code>insert_session()</code>","text":"<p>Create a session to insert data, which will automatically commit the data when the session ends.</p> <p>Returns:</p> Name Type Description <code>DataOpsSession</code> <code>DataOpsSession</code> <p>The session object.</p> Source code in <code>lynse/api/native_api/low_level.py</code> <pre><code>@unavailable_if_deleted\ndef insert_session(self):\n    \"\"\"\n    Create a session to insert data, which will automatically commit the data when the session ends.\n\n    Returns:\n        DataOpsSession (DataOpsSession): The session object.\n    \"\"\"\n    from ...execution_layer.session import DataOpsSession\n\n    return DataOpsSession(self)\n</code></pre>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.is_deleted","title":"<code>is_deleted()</code>","text":"<p>To check if the database is deleted.</p> <p>Returns:</p> Name Type Description <code>Bool</code> <p>True if the database is deleted, False otherwise.</p> Source code in <code>lynse/api/native_api/low_level.py</code> <pre><code>def is_deleted(self):\n    \"\"\"\n    To check if the database is deleted.\n\n    Returns:\n        Bool: True if the database is deleted, False otherwise.\n    \"\"\"\n    return self._matrix_serializer.IS_DELETED\n</code></pre>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.is_id_exists","title":"<code>is_id_exists(id)</code>","text":"<p>Check if the ID exists in the database.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID to check.</p> required <p>Returns:</p> Name Type Description <code>Bool</code> <p>True if the ID exists, False otherwise.</p> Source code in <code>lynse/api/native_api/low_level.py</code> <pre><code>@unavailable_if_deleted\ndef is_id_exists(self, id):\n    \"\"\"\n    Check if the ID exists in the database.\n\n    Parameters:\n        id (int): The ID to check.\n\n    Returns:\n        Bool: True if the ID exists, False otherwise.\n    \"\"\"\n    return id in self._matrix_serializer.id_filter\n</code></pre>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.list_field_index","title":"<code>list_field_index()</code>","text":"<p>List the field index.</p> <p>Returns:</p> Name Type Description <code>List</code> <p>The list of field indices.</p> Source code in <code>lynse/api/native_api/low_level.py</code> <pre><code>@unavailable_if_deleted\n@unavailable_if_empty\ndef list_field_index(self):\n    \"\"\"\n    List the field index.\n\n    Returns:\n        List: The list of field indices.\n    \"\"\"\n    return self._matrix_serializer.field_index.list_indices()\n</code></pre>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.list_fields","title":"<code>list_fields()</code>","text":"<p>Return all field names and their types.</p> <p>Returns:</p> Name Type Description <code>Dict</code> <p>A dictionary with field names as keys and field types as values.</p> Source code in <code>lynse/api/native_api/low_level.py</code> <pre><code>@unavailable_if_deleted\n@unavailable_if_empty\ndef list_fields(self):\n    \"\"\"\n    Return all field names and their types.\n\n    Returns:\n        Dict: A dictionary with field names as keys and field types as values.\n    \"\"\"\n    return self._matrix_serializer.field_index.storage.list_fields()\n</code></pre>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.query","title":"<code>query(query_filter, filter_ids=None, return_ids_only=False)</code>","text":"<p>Query the fields cache.</p> <p>Parameters:</p> Name Type Description Default <code>query_filter</code> <code>str</code> <p>Filter or dict or FieldExpression string The filter object or the specify data to filter.</p> required <code>filter_ids</code> <code>List[int]</code> <p>The list of external IDs to filter.</p> <code>None</code> <code>return_ids_only</code> <code>bool</code> <p>If True, only the external IDs will be returned.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>The records. If not return_ids_only, the records will be returned.</p> <code>List[int]</code> <p>The external IDs. If return_ids_only, the external IDs will be returned.</p> Source code in <code>lynse/api/native_api/low_level.py</code> <pre><code>@unavailable_if_deleted\n@unavailable_if_empty\ndef query(self, query_filter, filter_ids=None, return_ids_only=False):\n    \"\"\"\n    Query the fields cache.\n\n    Parameters:\n        query_filter (str): Filter or dict or FieldExpression string\n            The filter object or the specify data to filter.\n        filter_ids (List[int]):\n            The list of external IDs to filter.\n        return_ids_only (bool):\n            If True, only the external IDs will be returned.\n\n    Returns:\n        (List[Dict]): The records. If not return_ids_only, the records will be returned.\n        (List[int]): The external IDs. If return_ids_only, the external IDs will be returned.\n    \"\"\"\n    return self._matrix_serializer.field_index.query(query_filter, filter_ids, return_ids_only)\n</code></pre>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.query_vectors","title":"<code>query_vectors(query_filter, filter_ids=None)</code>","text":"<p>Query the vector data by the filter.</p> <p>Parameters:</p> Name Type Description Default <code>query_filter</code> <code>Filter or dict or FieldExpression str or None</code> <p>The filter object or the specify data to filter.</p> required <code>filter_ids</code> <code>list[int]</code> <p>The list of external IDs to filter. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[List[ndarray], List[int], List[Dict]]</code> <p>The vectors, IDs, and fields of the items.</p> Source code in <code>lynse/api/native_api/low_level.py</code> <pre><code>@unavailable_if_deleted\n@unavailable_if_empty\ndef query_vectors(self, query_filter, filter_ids=None):\n    \"\"\"\n    Query the vector data by the filter.\n\n    Parameters:\n        query_filter (Filter or dict or FieldExpression str or None):\n            The filter object or the specify data to filter.\n        filter_ids (list[int]):\n            The list of external IDs to filter. Default is None.\n\n    Returns:\n        (Tuple[List[np.ndarray], List[int], List[Dict]]): The vectors, IDs, and fields of the items.\n    \"\"\"\n    ids = self._matrix_serializer.field_index.query(query_filter, filter_ids, return_ids_only=True)\n    if not ids:\n        return np.array([]), np.array([]), []\n\n    return self.read_by_only_id(ids)\n</code></pre>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.read_by_only_id","title":"<code>read_by_only_id(id)</code>","text":"<p>Read the vector data by the external ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int or list</code> <p>The external ID or list of external IDs.</p> required <p>Returns:</p> Type Description <code>(Tuple[ndarray, List[int], List[Dict]], Tuple[ndarray, int, Dict])</code> <p>The vectors, IDs, and fields of the items.</p> Source code in <code>lynse/api/native_api/low_level.py</code> <pre><code>@unavailable_if_deleted\n@unavailable_if_empty\ndef read_by_only_id(self, id: Union[int, list]):\n    \"\"\"\n    Read the vector data by the external ID.\n\n    Parameters:\n        id (int or list): The external ID or list of external IDs.\n\n    Returns:\n        (Tuple[np.ndarray, List[int], List[Dict]], Tuple[np.ndarray, int, Dict]):\n            The vectors, IDs, and fields of the items.\n    \"\"\"\n    data, ids = self._matrix_serializer.storage_worker.read_by_only_id(id)\n\n    if data.shape[0] &gt; 0:\n        return np.asarray(ids), np.asarray(data), \\\n            self._matrix_serializer.field_index.retrieve_ids(ids, include_external_id=True)\n    return np.asarray(ids), np.asarray(data), []\n</code></pre>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.remove_all_field_indices","title":"<code>remove_all_field_indices()</code>","text":"<p>Remove all the field indices.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>lynse/api/native_api/low_level.py</code> <pre><code>@unavailable_if_deleted\n@unavailable_if_empty\ndef remove_all_field_indices(self):\n    \"\"\"\n    Remove all the field indices.\n\n    Returns:\n        None\n    \"\"\"\n    self._matrix_serializer.field_index.remove_all_field_indices()\n</code></pre>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.remove_field_index","title":"<code>remove_field_index(field_name)</code>","text":"<p>Remove the index for the field.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the field.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>lynse/api/native_api/low_level.py</code> <pre><code>@unavailable_if_deleted\n@unavailable_if_empty\ndef remove_field_index(self, field_name):\n    \"\"\"\n    Remove the index for the field.\n\n    Parameters:\n        field_name (str): The name of the field.\n\n    Returns:\n        None\n    \"\"\"\n    if not field_name.startswith(':') or not field_name.endswith(':'):\n        raise ValueError(\"The field name must be wrapped with ':'.\")\n\n    field_name = field_name.strip(':')\n    self._matrix_serializer.field_index.remove_index(field_name)\n</code></pre>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.remove_index","title":"<code>remove_index()</code>","text":"<p>Remove the vector index.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>lynse/api/native_api/low_level.py</code> <pre><code>@unavailable_if_deleted\n@unavailable_if_empty\ndef remove_index(self):\n    \"\"\"\n    Remove the vector index.\n\n    Returns:\n        None\n    \"\"\"\n    self._indexer.remove_index()\n    logger.info(\"Fallback to default index mode: `Flat-IP`.\")\n    self.build_index(index_mode='Flat-IP')  # Default index mode\n</code></pre>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.search","title":"<code>search(vector, k=10, *, search_filter=None, return_fields=False, **kwargs)</code>","text":"<p>Search the database for the vectors most similar to the given vector.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>ndarray or list</code> <p>The search vectors, it can be a single vector or a list of vectors. The vectors must have the same dimension as the vectors in the database, and the type of vector can be a list or a numpy array.</p> required <code>k</code> <code>int</code> <p>The number of nearest vectors to return.</p> <code>10</code> <code>search_filter</code> <code>Filter or FilterExpression string</code> <p>The filter to apply to the search.</p> <code>None</code> <code>return_fields</code> <code>bool</code> <p>Whether to return the fields of the search results.</p> <code>False</code> <code>kwargs</code> <p>Additional keyword arguments. The following are valid:</p> <ul> <li>rescore (bool): Whether to rescore the results of binary or scaler quantization searches.     Default is False. It is recommended to set it to True when the index mode is 'Binary'.</li> <li>rescore_multiplier (int): The multiplier for the rescore operation.     It is only available when rescore is True.     If 'Binary' is in the index mode, the default is 10. Otherwise, the default is 2.</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>Tuple[List[int], List[float], List[Dict]] or Tuple[List[int], List[float], None]</code> <p>If return_fields is True, the indices, similarity scores, and fields of the nearest vectors in the database. Otherwise, the indices and similarity scores of the nearest vectors in the database.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the database is empty.</p> Source code in <code>lynse/api/native_api/low_level.py</code> <pre><code>@unavailable_if_deleted\n@unavailable_if_empty\ndef search(self, vector: Union[np.ndarray, list], k: int = 10, *,\n           search_filter: Filter = None, return_fields=False, **kwargs):\n    \"\"\"\n    Search the database for the vectors most similar to the given vector.\n\n    Parameters:\n        vector (np.ndarray or list): The search vectors, it can be a single vector or a list of vectors.\n            The vectors must have the same dimension as the vectors in the database,\n            and the type of vector can be a list or a numpy array.\n        k (int): The number of nearest vectors to return.\n        search_filter (Filter or FilterExpression string, optional): The filter to apply to the search.\n        return_fields (bool): Whether to return the fields of the search results.\n        kwargs: Additional keyword arguments. The following are valid:\n\n            - rescore (bool): Whether to rescore the results of binary or scaler quantization searches.\n                Default is False. It is recommended to set it to True when the index mode is 'Binary'.\n            - rescore_multiplier (int): The multiplier for the rescore operation.\n                It is only available when rescore is True.\n                If 'Binary' is in the index mode, the default is 10. Otherwise, the default is 2.\n\n    Returns:\n        (Tuple[List[int], List[float], List[Dict]] or Tuple[List[int], List[float], None]):\n            If return_fields is True, the indices, similarity scores,\n            and fields of the nearest vectors in the database.\n            Otherwise, the indices and similarity scores of the nearest vectors in the database.\n\n    Raises:\n        ValueError: If the database is empty.\n    \"\"\"\n    raise_if(ValueError, not isinstance(vector, (np.ndarray, list)),\n             'vector must be np.ndarray or list.')\n\n    raise_if(TypeError, not isinstance(k, int) and not (isinstance(k, str) and k != 'all'),\n             'k must be int or \"all\".')\n    raise_if(ValueError, k &lt;= 0, 'k must be greater than 0.')\n    raise_if(ValueError, not isinstance(search_filter, (Filter, type(None), str)),\n             'search_filter must be Filter or None or FieldExpression string.')\n\n    # Convert the vector to np.ndarray\n    vector = np.atleast_2d(np.asarray(vector))\n\n    raise_if(ValueError, vector.shape[1] != self._matrix_serializer.shape[1],\n             'vector must be same dim with database.')\n\n    rescore = kwargs.setdefault('rescore', False)\n    rescore_multiplier = kwargs.setdefault('rescore_multiplier', 2)\n    raise_if(TypeError, not isinstance(rescore, bool), 'rescore must be bool.')\n    raise_if(TypeError, not isinstance(rescore_multiplier, int), 'rescore_multiplier must be int.')\n\n    if self._matrix_serializer.shape[0] == 0:\n        raise ValueError('database is empty.')\n\n    if k &gt; self._matrix_serializer.shape[0]:\n        k = self._matrix_serializer.shape[0]\n\n    if not self._use_cache:\n        self._search.single_search.clear_cache()\n\n    res = self._search.search(vector=vector, k=k, search_filter=search_filter,\n                              return_fields=return_fields, **kwargs)\n\n    return res\n</code></pre>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.tail","title":"<code>tail(n=5)</code>","text":"<p>Return the last n vectors in the database.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of vectors to return. Default is 5.</p> <code>5</code> <p>Returns:</p> Type Description <code>Tuple[List[ndarray], List[int], List[Dict]]</code> <p>The vectors, IDs, and fields of the items.</p> Source code in <code>lynse/api/native_api/low_level.py</code> <pre><code>@unavailable_if_deleted\n@unavailable_if_empty\ndef tail(self, n=5):\n    \"\"\"\n    Return the last n vectors in the database.\n\n    Parameters:\n        n (int): The number of vectors to return. Default is 5.\n\n    Returns:\n        (Tuple[List[np.ndarray], List[int], List[Dict]]): The vectors, IDs, and fields of the items.\n    \"\"\"\n    filenames = self._matrix_serializer.storage_worker.get_all_files()\n    filenames = sorted(filenames, key=lambda x: int(x.split('_')[-1].split('.')[0]))\n\n    data, indices = [], []\n\n    count = 0\n    dtypes = self._matrix_serializer.dtypes\n\n    for filename in filenames[::-1]:\n        data_chunk, index_chunk = self._matrix_serializer.dataloader(filename)\n        dtypes = data_chunk.dtype\n        data.insert(0, data_chunk)\n        indices = index_chunk.tolist() + indices\n        count += len(index_chunk)\n        if count &gt;= n:\n            break\n\n    if data:\n        return (np.asarray(indices)[-n:], np.vstack(data, dtype=dtypes)[-n:],\n                self._matrix_serializer.field_index.retrieve_ids(indices[-n:],\n                                                                 include_external_id=True))\n    return np.asarray(indices), np.array(data, dtype=dtypes), []\n</code></pre>"},{"location":"native_api/low_level/#lynse.api.native_api.low_level.ExclusiveDB.yield_every_single_element","title":"<code>yield_every_single_element(limit=None)</code>","text":"<p>Yield every single element in the database.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The maximum number of elements to yield. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[ndarray, int, Dict]</code> <p>The vectors, IDs, and fields of the items</p> Source code in <code>lynse/api/native_api/low_level.py</code> <pre><code>@unavailable_if_deleted\n@unavailable_if_empty\ndef yield_every_single_element(self, limit=None):\n    \"\"\"\n    Yield every single element in the database.\n\n    Parameters:\n        limit (int): The maximum number of elements to yield. Default is None.\n\n    Returns:\n        (Tuple[np.ndarray, int, Dict]): The vectors, IDs, and fields of the items\n\n    \"\"\"\n    raise_if(TypeError, limit is not None and not isinstance(limit, int), \"limit must be an integer.\")\n    filenames = self._matrix_serializer.storage_worker.get_all_files()\n    filenames = sorted(filenames, key=lambda x: int(x.split('_')[-1].split('.')[0]))\n\n    count = 0\n    for filename in filenames:\n        data_chunk, index_chunk = self._matrix_serializer.dataloader(filename)\n        for i in range(len(index_chunk)):\n            yield int(index_chunk[i]), np.asarray(data_chunk[i]), \\\n                self._matrix_serializer.field_index.retrieve([index_chunk[i]], include_external_id=True)\n            count += 1\n            if limit and count &gt;= limit:\n                return\n</code></pre>"},{"location":"tutorials/add_vectors/","title":"Tutorial: Add vectors","text":"<p>First, import the LynseDB client:</p> <pre><code>import lynse\n</code></pre> <p>And then, Start the server, you can specify the root path directly <pre><code>client = lynse.VectorDBClient(uri=\"demo\")\nmy_db = client.create_database(\"my_vec_db\", drop_if_exists=False)\n</code></pre></p>"},{"location":"tutorials/add_vectors/#sequentially-add-vectors","title":"Sequentially add vectors","text":"<p>create or truncate a collection: <pre><code>collection = my_db.require_collection(\"test_add_vectors\", dim=128, drop_if_exists=True)\n</code></pre></p> <p>The <code>add_item</code> API can be used to add vectors to the database one by one, and it is recommended to always submit data within the <code>insert_session</code> context manager to ensure the highest level of data security: <pre><code>import numpy as np\n\n# If the field is not passed, a blank string field will be used.\n# The add_item function returns the id of the data by default.\nwith collection.insert_session() as session:\n    id = session.add_item(vector=np.random.random(128), id=1, field={'test': 'test', 'test1': 'test2'})\n\n# If you do not use the insert_session function, you need to manually call the commit function to submit the data\n# collection.commit()\n</code></pre></p> <pre><code>2024-09-13 10:44:57 - LynseDB - INFO - Saving data...\n2024-09-13 10:44:57 - LynseDB - INFO - Writing chunk to storage...\nData persisting: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00&lt;00:00, 264.76chunk/s]\n\n2024-09-13 10:44:57 - LynseDB - INFO - Writing chunk to storage done.\n2024-09-13 10:44:57 - LynseDB - INFO - Pre-building the index...\n2024-09-13 10:44:57 - LynseDB - INFO - Building an index using the `Flat-IP` index mode...\n2024-09-13 10:44:57 - LynseDB - INFO - Index built.\n</code></pre> <p>Now we can see what content the <code>id</code> returns</p> <pre><code>print(id)\n</code></pre> <pre><code>1\n</code></pre> <p>Print <code>collection</code> to get some information about it <pre><code>print(collection)\n</code></pre></p> <pre><code>LocalCollectionInstance(\n    database=\"my_vec_db\",\n    collection=\"test_add_vectors\",\n    shape=(1, 128)\n)\n</code></pre>"},{"location":"tutorials/add_vectors/#add-vectors-in-bulk","title":"Add vectors in bulk","text":"<p>Now let's try to add vectors in bulk: <pre><code>collection = my_db.require_collection(\"test_min_vec\", dim=128, drop_if_exists=True)\n</code></pre></p> <p>Similarly, we use the <code>bulk_add_items</code> method within the <code>insert_session</code> context manager to submit all the data at once: <pre><code>import numpy as np\n\nvectors = []\n\nwith collection.insert_session() as session:\n    for i in range(10):\n        # The order is vector, id, field\n        vectors.append((np.random.random(128), i, {'test': f'test_{i}'}))\n\n\n    ids = session.bulk_add_items(vectors)\n\nprint(ids)\n</code></pre></p> <pre><code>2024-09-13 10:45:14 - LynseDB - INFO - Saving data...\n2024-09-13 10:45:14 - LynseDB - INFO - Writing chunk to storage...\nData persisting: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00&lt;00:00, 460.86chunk/s]\n\n2024-09-13 10:45:14 - LynseDB - INFO - Writing chunk to storage done.\n2024-09-13 10:45:14 - LynseDB - INFO - Pre-building the index...\n2024-09-13 10:45:14 - LynseDB - INFO - Building an index using the `Flat-IP` index mode...\n2024-09-13 10:45:14 - LynseDB - INFO - Index built.\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre> <p>Isn't it simple? At this point, we can check if the shape of the <code>collection</code> is correct: <pre><code>print(collection)\n</code></pre></p> <pre><code>LocalCollectionInstance(\n    database=\"my_vec_db\",\n    collection=\"test_min_vec\",\n    shape=(10, 128)\n)\n</code></pre>"}]}